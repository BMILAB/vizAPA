#' @importFrom magrittr %>%
#' @importFrom ggbio tracks
#' @importFrom movAPA summary
#' @importFrom methods new
#' @importFrom RColorBrewer brewer.pal
#' @importFrom GenomicRanges GRanges reduce resize mcols "mcols<-" findOverlaps
#' width start end strand seqnames gaps makeGRangesFromDataFrame
#' @importFrom IRanges IRanges subsetByOverlaps
#' @importClassesFrom Matrix dgCMatrix dgeMatrix
#' @importFrom ggplot2 element_rect element_line aes theme_bw theme element_text ggplot geom_line xlab ylab
#' element_blank ggtitle facet_grid facet_wrap aes_string stat_ecdf labs annotate geom_point geom_vline
#' scale_colour_manual labs margin scale_y_continuous theme_classic scale_fill_gradientn guides .data
#' geom_text position_dodge ylim guide_legend scale_color_gradient coord_flip geom_boxplot scale_fill_manual
#' geom_violin geom_jitter position_jitterdodge scale_colour_gradient2 scale_fill_viridis_c theme_void
#' geom_area geom_raster geom_segment
#' @importFrom Matrix as.matrix colMeans colSums rowMeans rowSums t
#' @importFrom utils head
#' @importFrom SeuratObject "Idents<-"
NULL

#GRanges makeGRangesFromDataFrame strand start end mcols width
options(stringsAsFactors = FALSE)

#library(movAPA)
#library(ggbio)
#library(testthat)
#library(Seurat)
#library(GenomicRanges)
#library(GenomicFeatures)
#library(Rsamtools)
#library(bamsignals)
#library(biomaRt)
#library(rtracklayer)
#library(AnnotationFilter)
#library(tidyverse)
#library(stringr)
#library(RColorBrewer)
#library(ggpubr)


## rm(list=ls())
## setwd("D:/xhwu/sys/code/R/vizAPA/vizAPA")
## devtools::check()
## devtools::load_all()
## roxygen2::roxygenise()
## >>> Writing LOG.Rd
## build&reload
## devtools::build(binary=TRUE)

## detach(package:vizAPA)
## devtools::unload('vizAPA')
## remove.packages("vizAPA")
## install.packages("D:/xhwu/sys/code/R/vizAPA/vizAPA_0.1.0.tar.gz", repos = NULL, type = "source")
## install.packages("D:/xhwu/sys/code/R/vizAPA/vizAPA_0.1.0.zip", repos = NULL, type = "win.binary")
## library(vizAPA)

# ------------------- data -------------------------------
## package?vizAPA
#' @details
#' The vizAPA package is a comprehensive package for Visualization of dynamics of alternative PolyAdenylation in single cells.
#' vizTracks to plot gene model, pAs and BAM coverages, vizStats to summarize pA usages across cell categories, vizUMAP to plot 2D-embeddings, vizAPAmarkers to visualize APA markers across cell categories, etc.
#' The package is not species-specific, so it can be used for any species. The genome annotation could be retrieved from several sources, including gff3/gtf file, TxDb, EnsDb, BioMart, and OrganismDb. Users can provide one or more annotation sources.
#' @references
#' Zhu, S., et al. (2020) PlantAPAdb: A Comprehensive Database for Alternative Polyadenylation Sites in Plants, Plant Physiol., 182, 228-242.
#'
#' Wu, X., et al. (2011) Genome-wide landscape of polyadenylation in Arabidopsis provides evidence for extensive alternative polyadenylation, Proc. Natl. Acad. Sci. USA, 108, 12533-12538.
"_PACKAGE"


#' A demo PACdataset of mouse sperm cells
#'
#' A dataset of the PACdataset class from mouse sperm cells, containing 974 PACs from 413 genes.
#' There are total 955 cells from three cell types (SC, Spermatocytes; RS, Round spermatids; ES, Elongating spermatids).
#' This dataset contains the gene Odf4 (252868, ENSMUSG00000032921) and Arl2bp (107566, ENSMUSG00000031776) presented in Wu et al, Briefings Bioinf, 2021.
#' The raw data was obtained from NCBI (accession number: GSM280334), and pAs were extracted by scAPAtrap.
#' Only genes containing at least one top 500 pAs ranked by the total number of reads were retained in this dataset for demonstration.
#'
#' @docType data
#' @name scPACds
#' @format A PACdataset with 974 PACs from mouse sperm cells.
#' @source Generated by scAPAtrap and annotated by movAPA.
#' @examples
#' data(scPACds)

# -------------- *** utils **** ---------------

.asDf <-function(dat) {
  return(movAPA:::.asDf(dat))
}

#' win2linuxPath converts Windows file name to Linux.
#' @param aPath a string
#' @param addBar whether to add / in the end of the string, default is FALSE
#' @return a new string in Linux format
#' @examples
#' win2linuxPath('data\\a.bam') # "data/a.bam"
#' win2linuxPath('data/a.bam') # "data/a.bam"
#' win2linuxPath('data/a.bam', addBar=T) # "data/a.bam/"
#' win2linuxPath('data/a.bam/', addBar=T) # "data/a.bam/"
win2linuxPath <- function(aPath, addBar=FALSE) {
  new_path <- gsub(pattern = "\\", replacement = "/", x = aPath, fixed = TRUE)
  if (addBar) {
    if (substr(new_path, nchar(new_path), nchar(new_path)) != '/')
      new_path=paste0(new_path, '/')
  }
  return(new_path)
}

# Whether A in B
# @param A a vector
# @param B a vector
# @param all whether need all A in B
# @return TRUE/FALSE
# @examples
# AinB(c('start','end'),c('start','x','y'),all=T) #false
# AinB(c('start','end'),c('start','x','y'),all=F) #true
# AinB(c(),c('start','x','y'),all=F) #true
AinB<-function(A, B, all=T){
  if (is.null(A)) return(TRUE)
  if (length(A)==0) return(TRUE)
  #cat('all', all ,class(A), class(B), '\n')
  if (is.factor(A))   A=as.character(A)
  if (is.factor(B))   B=as.character(B)
  if (!(is.vector(A) & is.vector(B))) {
    return(F)
  }
  #print(A); print(B)
  x=sum(A %in% B)
  if ((all & x==length(A)) | (!all & x>0)) {
    return(T)
  } else {
    return(F)
  }
}

# validate.arg(NULL, c('a','b','c', 'no')) --> a
# validate.arg('x', c('a','b','c', 'no')) --> error
# validate.arg(NULL, c('a','b','c', 'no'), null2default=FALSE)  --> error
# validate.arg(NULL, c('a','b','c', 'no', NULL), null2default=FALSE)  --> error
validate.arg <- function(arg, choices, several.ok = FALSE, null2default = TRUE, lc = TRUE) {
  if (is.null(arg)) {
    if (null2default) arg=choices[1]
  }
  if (lc) arg=tolower(arg)
  arg = match.arg(arg, choices, several.ok)
  return(arg)
}

#' Log transformation of a PACdataset

#' logPACds does log2/10 transformation of a PACdataset.
#'
#' @param PACds A PACdataset.
#' @param log Can be 2 or 10 means log2 or log10.
#' @param psu Pseudo count to avoid log(0).
#' @param logWhenCounts If TRUE then only do log when PACds's dataType is count.
#' @return A PACdataset.
#' @examples
#' logPACds(PACds)
#' @name logPACds
#' @family PACdataset functions
#' @export
logPACds <- function(PACds, log=2, psu=1, logWhenCounts=TRUE) {

  if (logWhenCounts) {
    PACds=suppPACds(PACds, refresh = TRUE)
    if (PACds@supp$dataType=='count') {
      if (log==2) PACds@counts=movAPA::asAnyMatrix(log2(PACds@counts+psu))
      if (log==10) PACds@counts=movAPA::asAnyMatrix(log10(PACds@counts+psu))
    }
  } else {
    if (log==2) PACds@counts=movAPA::asAnyMatrix(log2(PACds@counts+psu))
    if (log==10) PACds@counts=movAPA::asAnyMatrix(log10(PACds@counts+psu))
  }
  return(PACds)
}

# -------- class annoSource -------------

ANNOTYPES=c(txdb='TxDb',ensdb='EnsDb',biomart='Mart', orgdb='OrganismDb', gff='list', genes='data.frame')

#' annoHub object
#'
#' annoHub is an S4 class to store different genome annotation sources.
#'
#' @slot annos A list storing different annotation sources: txdb=TxDb, ensdb=EnsDb, orgdb=OrganismDb, biomart=Mart, gff=list from useGff(), genes=data.frame of a user provided gene ranges.
#' @slot chrMappings A data frame storing the mappings of chromosome names (seqnames).
#' @slot defaultAnno The anno name of the default annotation.
#' @family annotation functions
annoHub <- setClass("annoHub", representation(annos="list",
                                              chrMappings="data.frame",
                                              defaultAnno="character"))  # validity = checkAnnoHub

# annoSource=new("annoHub")
# validObject(annoSource) # TRUE
# new("annoHub", annos=list(txdb=1)) #error: annos$txdb is not TxDb
# new("annoHub", defaultAnno='gff') #error: defaultAnno not in names(annos)!
setValidity("annoHub", function(object) {
  msg=c()
  annos=object@annos

  #if (!AinB(names(annos), names(ANNOTYPES), all=T)) msg=c(msg, paste0("names of annos not all in ", paste0(names(ANNOTYPES), collapse = ',')))

  for (i in names(annos)) {
    an=annoType(annos[[i]], '')
    if (an=='') {
      if (i %in% names(ANNOTYPES)) { # annos$txdb=notTXDB
        msg=c(msg, paste0("annos$",i, " is not ", ANNOTYPES[i])) #annos$txdb is not TxDb
      } else { # annos$unkown
        msg=c(msg, paste0("annos$",i, " is unknown anno"))
      }
    } else { # annos$txdb=orgdb
      if (i!=an) msg=c(msg, paste0("annos$",i, " is not ", ANNOTYPES[i]))
    }

  }

  if (nrow(object@chrMappings)>0) {
    if (ncol(object@chrMappings)<=1) {
      msg=c(msg, "@chrMappings only contains one columns, not a chr-mapping data frame!")
    }
  }

  if (length(object@defaultAnno)>0) {
    if (length(object@defaultAnno)!=1)  msg=c(msg, "defaultAnno should be length=1!")
    if (!(object@defaultAnno[1] %in% names(annos))) msg=c(msg, "defaultAnno not in names(annos)!")
  }

  if (length(msg)>0) {
    cat(paste(msg,sep="\n"))
    return(FALSE)
  }
  return(TRUE)
})

# ah=new("annoHub")
# is.empty(ah)
# is.empty(new("annoHub"))
setGeneric("is.empty", function(annoSource) standardGeneric("is.empty"))

setMethod("is.empty", signature(annoSource = "annoHub"), def=function(annoSource) {
  annos=annoSource@annos
  if (length(annos)==0) return(TRUE)
  if (sum(unlist(lapply(annos, is.null))) == length(annos)) {
    return(TRUE)
  }
  return(FALSE)
}
)

# annoNames(ah)
setGeneric("annoNames", function(annoSource) standardGeneric("annoNames"))

setMethod("annoNames", signature(annoSource = "annoHub"), def=function(annoSource) {
  annos=annoSource@annos
  return(names(annos))
}
)


# new("annoHub", annos=list(txdb=txdb), chrMappings=data.frame(1:3))
# --> gff=list \n txdb=TxDb
setMethod("show",
          "annoHub",
          function(object) {
            cat("@annos [annotation sources]:\n")
            an=names(object@annos)
            cls=unlist(lapply(object@annos, class))
            cat(paste0(paste(an, cls, sep='='), collapse = '\n'))

            if (nrow(object@chrMappings)>0) {
              cat('\n@chrMappings:\n')
              print(head(object@chrMappings, 2))
            }

            if (length(object@defaultAnno)>0) cat('\n@defaultAnno:\n',object@defaultAnno[1],'\n')
          }
)

# ah=new("annoHub"); ah=addAnno(ah, txdb); length(ah)
setMethod("length",
          signature(x="annoHub"),
          function(x) {
            return(length(x@annos))
          }
)

#overloading of subscript operator
# ah=new("annoHub", annos=list(gff=list(1, 2, 3), txdb=txdb))
# ah[1] #-->gff
# ah['txdb']
setMethod("[", signature(x = "annoHub"), def=function(x, i, ...) {
  if (!missing(i)) {
    x=x@annos[[i]]
  }
  return(x)
}
)

# ah[['txdb']]
setMethod("[[", signature(x = "annoHub"), def=function(x, i, ...) {
  if (!missing(i)) {
    x=x@annos[[i]]
  }
  return(x)
}
)

# annoType(annoSource['gff'])
# annoType(annoSource['genes'])
# annoType(annoSource['txdb'])
# annoType('hh') --> ''
# annoType('hh', 'unkown') --> unkown
annoType<-function(obj, un='') {

  if (inherits(obj, 'TxDb')) return('txdb')
  if (inherits(obj, 'EnsDb')) return('ensdb')
  if (inherits(obj, 'Mart')) return('biomart')
  if (inherits(obj, 'OrganismDb')) return('orgdb')

  if (inherits(obj, 'data.frame') & AinB(c('chr','strand','start','end'), colnames(obj), all=TRUE)) {
    if (length(grep('gene', colnames(obj))>0)) return('genes')
  }

  if (inherits(obj, 'list')) {
    if (AinB(c('anno.need', 'anno.rna', 'anno.frame'), names(obj)))
      return('gff')
  }
  return(un)
}


#' addAnno generic
#'
#' addAnno is a generic function to add a annotation source to the annoHub object.
#'
#' @param annoSource An annoHub object.
#' @param anAnno An annotation source: txdb=TxDb, ensdb=EnsDb, orgdb=OrganismDb, biomart=Mart, gff=list from useGff(), genes=user provided data.frame.
#' @param ... dot arguments.
#' @family annotation functions
setGeneric("addAnno", function(annoSource, anAnno, ...) standardGeneric("addAnno"))

#' Add an annotation to annoHub
#'
#' addAnno adds a annotation source to the annoHub object.
#' @param overwrite TRUE to overwrite the existing anno in annoSource, otherwise error is raised when the anno already exists.
#' @return An annoHub object.
#' @examples
#' library(Mus.musculus)
#' orgdb=Mus.musculus
#' ah=new("annoHub")
#' ah=addAnno(ah, orgdb)
#' @export
setMethod("addAnno", signature(annoSource = "annoHub"), def=function(annoSource, anAnno, overwrite=TRUE) {

  an=annoType(anAnno)

  if (an=='') stop('addAnno error: unkown type of anAnno, should be list/TxDb/EnsDb/Mart/OrganismDb/genes!')

  if (!overwrite & (an %in% annoNames(annoSource))) stop('addAnno error: anAnno already in annoSource but overwrite=FALSE!')

  annoSource@annos[[an]]=anAnno
  if (length(annoSource@defaultAnno)==0) annoSource@defaultAnno=names(annoSource@annos)[1]

  methods::validObject(annoSource)

  return(annoSource)
}
)


#' setDefaultAnno generic
#'
#' setDefaultAnno is a generic function to set the default annotation source for an annoHub.
#'
#' @param annoSource An annoHub object.
#' @param annoName A character or a numeric index of the anno.
#' If it is a character, should be exdb/ensdb/orgdb/gff/biomart/genes.
#' @family annotation functions
setGeneric("setDefaultAnno", function(annoSource, annoName) standardGeneric("setDefaultAnno"))

#' Set a default anno for annoHub
#'
#' setDefaultAnno sets the default annotation source for an annoHub.
#'
#' @return An annoHub object.
#' @examples
#' library(Mus.musculus)
#' orgdb=Mus.musculus
#' annoSource=new("annoHub")
#' annoSource=addAnno(annoSource, orgdb)
#' annoSource=setDefaultAnno(annoSource, 'orgdb')
#' annoSource=setDefaultAnno(annoSource, 1)
#' @export
setMethod("setDefaultAnno", signature(annoSource = "annoHub"), def=function(annoSource, annoName) {

  if (length(annoSource)==0) stop("The annoSource is empty, cannot setDefaultAnno!")
  if (length(annoName)!=1) stop("annoName should be of length 1 in numeric or charater!")

  if (is.numeric(annoName)) {
    if (annoName>length(annoSource)) stop("annoName > length of annoSource!")
    annoName=annoNames(annoSource)[annoName]
  }

  if (is.character(annoName)) {
    if (!(annoName %in% annoNames(annoSource))) stop("annoName not in annoSource!")
  }

  annoSource@defaultAnno=annoName
  methods::validObject(annoSource)
  return(annoSource)
}
)

# getDefaultAnno(annoSource)
setGeneric("getDefaultAnno", function(annoSource, id) standardGeneric("getDefaultAnno"))


setMethod("getDefaultAnno", signature(annoSource = "annoHub"), def=function(annoSource, id=NULL) {
  if (length(annoSource@defaultAnno)>0) {
    return(annoSource[annoSource@defaultAnno[1]])
  } else if (!is.null(id)) {
    return(annoSource[id])
  }
}
)


.getOneAnnoChrs<-function(obj) {
  an=annoType(obj)
  if (an=='txdb') return(names(GenomeInfoDb::seqlengths(obj)))
  if (an=='ensdb') return(GenomeInfoDb::seqlevels(obj))
  if (an=='biomart') return(biomaRt::getBM(attributes = 'chromosome_name', mart=obj)[,1])
  if (an=='orgdb') return(GenomeInfoDb::seqlevels(obj))
  if (an=='genes') return(unique(as.character(obj$chr)))
  if (an=='gff')  return(unique(as.character(obj$anno.rna$seqnames)))
  return('')
}

#' getAnnoChrs generic
#'
#' getAnnoChrs is a generic function to get chrs from an anno of annoHub.
#'
#' @param annoSource An annoHub object.
#' @param ... dot arguments.
#' @family annotation functions
setGeneric("getAnnoChrs", function(annoSource, ...) standardGeneric("getAnnoChrs"))

#' Get chrs from annoHub
#'
#' getAnnoChrs gets chrs from an anno of annoHub
#' @param which A character of the anno, should be exdb/ensdb/orgdb/gff/biomart/genes.
#' @return A vector of chr names.
#' @examples
#' library(Mus.musculus)
#' orgdb=Mus.musculus
#' annoSource=new("annoHub")
#' annoSource=addAnno(annoSource, orgdb)
#' getAnnoChrs(annoSource, 'orgdb')
#' @export
setMethod("getAnnoChrs", signature(annoSource = "annoHub"), def=function(annoSource, which=NULL) {
  if (missing(which) | is.null(which)) {
    if (is.empty(annoSource)) return(c()) #stop('annoSource is an annoHub, but is empty!')
    annoSource=annoSource[annoSource@defaultAnno]
  } else {
    if (!(which %in% annoNames(annoSource))) stop('annoSource is an annoHub, but which not in annoNames(annoSource)!')
    annoSource=annoSource[which]
  }
  .getOneAnnoChrs(annoSource)
}
)



# -------------- *** Annotation **** ---------------

#' Parse a genome annotation file or a TxDb object
#'
#'  useGff parse genome annotation file of gtf/gff3 format or genome annotation object of TxDb, which could be further used for annotating a PACdataset.
#' @param gff An annotation file in gtf/gff3 format.
#' @param txdb A TxDb object, e.g., TxDb.Athaliana.BioMart.plantsmart28.
#' Either gff or txdb should be provided.
#' @return A parsed genome annotation stored in a list with three dataframes.
#' @examples
#' \dontrun{
#' ## Way1: Based on an annotation file in gtf/gff3 format
#' gtf.data <- useGff(gff = "Arabidopsis_thaliana.TAIR10.49.gtf")
#'
#' ##Way2: Based on a TxDb object generated from BioMart.
#' # Parse Arabidopsis Txdb
#' library(TxDb.Athaliana.BioMart.plantsmart28)
#' txdb <- useGff(TxDb.Athaliana.BioMart.plantsmart28)
#'
#' # Parse mm10 Txdb
#' BiocManager::install("TxDb.Mmusculus.UCSC.mm10.ensGene")
#' library(TxDb.Mmusculus.UCSC.mm10.ensGene)
#' txdb <- useGff(TxDb.Mmusculus.UCSC.mm10.ensGene)
#'
#' ## Not run:
#' # to download gff file of a species from other databases,
#' # users could use biomartr::getGFF(), for example,
#' # download the annotation of Arabidopsis thaliana from refseq
#' # and store the corresponding genome file in '_ncbi_downloads/annotation'
#' getGFF( db       = "refseq",
#'         organism = "Arabidopsis thaliana",
#'         gunzip = TRUE
#'         path = file.path("_downloads","annotation"))
#' # then users could use useGff to load the gff file into vizAPA
#' useGff(gff='_downloads/annotation/Arabidopsis_thaliana_genomic_refseq.gff')
#' }
#' @name useGff
#' @family annotation functions
#' @export
useGff<- function (gff=NULL, txdb=NULL){
  if (is.null(gff) & is.null(txdb)) {
    stop("Please provide a gff file path or a Txdb object!")
  }
  if (!is.null(gff) & !is.null(txdb)) {
    stop("Please provide either a gff file path or a Txdb object!")
  }

  if (!is.null(gff)) {
    if (grepl('\\.gff3|\\.gtf', tolower(gff))) {
      rt=movAPA::parseGff(gff)
      invisible(gc())
      return(rt)
    } else {
      stop("gff filename should be .gff3/.gtf!")
    }
  }

  if(!is.null(txdb)){
    if (inherits(txdb, 'TxDb')) {
      rt=movAPA::parseTxdb(txdb)
      invisible(gc())
      return(rt)
    } else {
      stop('txdb is not a TxDb object!')
    }
  }
}

#' Get chromosome names
#'
#' getChrs gets the chromosome names of any given object
#' @param obj An obj of any class (PACdataset, bam file list, annoSource list, txdb/gff/ensdb/biomart/orgdb, dataframe/matrix, bsgenome, fafile).
#' @param which Specify the element in a list for retrieving chr names or a column in a dataframe or matrix denoting the chr column. For a list (such as annoSource), the obj in the list to get chr is specified by which. For a dataframe/matrix, which specifies the chr column name, when 'seqnames' or 'chr' does not exist in colnames.
#'              By default, if which=NULL, then the first item of a list (if obj is a list) is considered, or 'seqnames' or 'chr' column is searched first (when obj is matrix/data.frame).
#' @return A character vector with chromosome names.
#' @examples
#' getChrs(1:3)
#' # get chrs from a dataframe or matrix
#' data(scPACds)
#' getChrs(scPACds@anno)
#' getChrs(scPACds@anno, which='seqnames') ##error: which not in df
#' getChrs(scPACds@anno, which='chr')
#' # get chrs from a PACdataset
#' getChrs(scPACds)
#' \dontrun{
#' # get chr names from a parse GFF object
#' gff <- useGff(gff ="data/Arabidopsis_thaliana.TAIR10.49.gtf")
#' getChrs(gff)
#' }
#' # get chrs from a TxDb object
#' library(TxDb.Hsapiens.UCSC.hg19.knownGene)
#' getChrs(TxDb.Hsapiens.UCSC.hg19.knownGene)
#' # get chrs from an EnsDb object
#' library(EnsDb.Hsapiens.v75)
#' getChrs(EnsDb.Hsapiens.v75)
#' # get chrs from an OrgDb object
#' library(Homo.sapiens)
#' getChrs(Homo.sapiens)
#' # get chrs from biomart
#' bm <- useMart(biomart="plants_mart",
#'              host="https://plants.ensembl.org", dataset="athaliana_eg_gene")
#' getChrs(bm)
#' # different annotation sources can be put in a list,
#' # which=NULL will get chrs from the first element in the list
#' getChrs(obj=list(biomart=bm), which=NULL)
#' # specify which
#' getChrs(obj=list(biomart=bm,
#'        txdb=TxDb.Hsapiens.UCSC.hg19.knownGene),
#'        which='txdb')
#' \dontrun{
#' # get chrs from a BAM file list
#' bams=readBAMFileNames(...)
#' getChrs(bams)
#' }
#' @name getChrs
#' @family annotation functions
#' @export
getChrs <-function(obj, which=NULL) {

  .getBAMchrs <- function(aBamFile) {
    chr <- GenomeInfoDb::seqnames(GenomeInfoDb::seqinfo(Rsamtools::BamFile(aBamFile)))
    return(as.character(chr))
  }

  if (is.numeric(obj) | is.character(obj) | is.factor(obj)) {
    return(as.character(obj))
  }

  if (inherits(obj, 'data.frame')) { ## bams
    if ('fileName' %in% colnames(obj)) return(.getBAMchrs(obj$fileName[1]))
  }

  if (inherits(obj, 'data.frame') | inherits(obj, 'matrix')) {
    if (is.null(which)) which='chr'
    if (!(which %in% colnames(obj))) {
      if ('seqnames' %in% colnames(obj)) {
        which='seqnames'
      } else if ('chr' %in% colnames(obj)) {
        which='chr'
      } else {
        stop('The chr column', which,' or chr/seqnames not in the dataframe or matrix obj!')
      }
    }
    return(unique(as.character(obj[, which])))
  }

  if (inherits(obj, 'PACdataset')) {
    return(unique(as.character(obj@anno$chr)))
  }

  if (annoType(obj) %in% c('txdb', 'ensdb', 'biomart', 'orgdb', 'gff', 'genes')) return(.getOneAnnoChrs(obj))

  if (inherits(obj, 'annoHub')) { ##annoSource obj
    return(getAnnoChrs(obj, which))
  }

  if (inherits(obj, 'BSgenome')) {
    return(GenomeInfoDb::seqnames(obj))
  }

  if (inherits(obj, 'FaFile')) {
    if (!file.exists(obj$index)) {
      cat("Indexing fa...\n")
      Rsamtools::indexFa(obj$path)
    }
    return(names(GenomeInfoDb::seqlengths(obj)))
  }

  warning("Do not know the obj type, return empty str.\n")
  return('')
}

#' Check consistency of chromosome names among different objects
#'
#' isChrConsistent checks the consistency of chromosome names among any number of given objects, e.g., PACdataset, dataframe/matrix, genome annotation sources, BSgenome.
#'
#' @param ... Any number of objects, e.g, PACdataset, bam file names, an annoHub or a parsed gff, txdb/gff/ensdb/biomart/orgdb, dataframe/matrix, bsgenome, fafile. See getChrs() for supported classes.
#' @param which Specify the element in a list or a column in a dataframe or matrix for retrieving chr names.
#'              For an annoHub, the object is specified by which. For a dataframe/matrix, 'which' specifies the chr column name (if seqnames or chr not exists).
#' @param exact Define the consistency of chr names among the given objects, with FALSE being partially overlapped of chrs (>=1 intersects)  or TRUE completely the same.
#' @param verbose TRUE to print the message.
#' @return TRUE if the chr names are (partially or exactly) consistent among objects, or FALSE if not.
#' @examples
#' \dontrun{
#' # Load different genome annotation sources
#' txdb=TxDb.Hsapiens.UCSC.hg19.knownGene
#' ensdb=EnsDb.Hsapiens.v75
#' orgdb=Homo.sapiens
#' bm <- useMart(biomart="plants_mart", host="https://plants.ensembl.org", dataset="athaliana_eg_gene")
#' gff <- useGff(gff ="data/Arabidopsis_thaliana.TAIR10.49.gtf")
#' # check the consistency of chr names
#' isChrConsistent(txdb, ensdb, orgdb) #FALSE
#' isChrConsistent(orgdb, txdb) #TRUE
#' isChrConsistent(orgdb, txdb, exact=TRUE) #TRUE
#' isChrConsistent(gff, bm, exact=TRUE) # #TRUE
#' isChrConsistent(c(1:5,'Mt','Pt'), bm, exact=TRUE) #TRUE
#' isChrConsistent(c(1:5,'chr1','chr2'), bm, exact=TRUE) ##FALSE
#' isChrConsistent(c(1:5,'chr1','chr2'), bm, exact=FALSE) ##TRUE
#' ah=new("annoHub", annos=list(biomart=bm, gff=gff))
#' isChrConsistent(c(1:5,'chr1','chr2'), ah) ##TRUE
#' isChrConsistent(c(1:5,'chr1','chr2'), ah, which='gff') ##TRUE
#' isChrConsistent(c(1:5,'chr1','chr2'), ah, which='XXX') ##Error!
#' isChrConsistent(c(1:5,'chr1','chr2'), ah, bams, which='gff') ##TRUE
#' isChrConsistent(c(1:5,'chr1','chr2'), ah, bams, which='gff', exact=TRUE) ##FALSE
#' }
#' @name isChrConsistent
#' @family annotation functions
#' @export
isChrConsistent <- function(..., which=NULL, exact=FALSE, verbose=TRUE) {
  pars=list(...)
  #print(substitute(pars))
  if (length(pars)==0) return(TRUE)
  if (length(pars)==1) return(TRUE)
  for (i in 1:(length(pars)-1))
    for (j in (i+1):length(pars)) {
      p1=pars[[i]]
      p2=pars[[j]]
      if (is.null(p1) | is.null(p2)) next
      chr1=getChrs(p1, which=which)
      chr2=getChrs(p2, which=which)
      if (!AinB(chr1, chr2, all=exact)) {
        if (verbose) {
          cat('chrs not consistent!\n')
          cat('obj1:',chr1[1:min(10,length(chr1))],'...\n')
          cat('obj2:',chr2[1:min(10,length(chr2))],'...\n')
        }
        return(FALSE)
      }
    }
  return(TRUE)
}


## converts a chr region string to a list with chr/strand/start/end or a GRange
# .covStrRegion() --> NA list
# .covStrRegion('chr1:+:3000:9000')
# .covStrRegion('chr1;+;3000;9000', sep=';')
# .covStrRegion('chr1;+;3000;9000', sep=';', rt='gr')
# .covStrRegion('chr1:*:3000:9000')
.covStrRegion <- function(genomicRegionStr=NULL, sep=":", check=TRUE, rt="list") {

  rt=validate.arg(rt, c('list','gr','ranges'))

  if (rt=='list') {
    emptyRt=list(chr=NA, strand=NA, start=NA, end=NA)
  } else {
    emptyRt=GRanges()
  }

  if (is.null(genomicRegionStr)) return(emptyRt)

  region<-strsplit(genomicRegionStr, sep, fixed=T)

  if (length(region)!=1) {
    if (check) stop("error region format (",genomicRegionStr,"), e.g., chr1:+:3000:9000")
    return(emptyRt)
  }
  region=region[[1]]
  if (length(region)!=4) {
    if (check) stop("error region format (",genomicRegionStr,"), e.g., chr1:+:3000:9000")
    return(emptyRt)
  }
  chr<-region[1]
  strand<-region[2]
  start<-as.numeric(region[3])
  end<-as.numeric(region[4])

  if (check) {
    if (end<start) stop("error region (",genomicRegionStr,"): end<start !")
    if (end<0 | start<0) stop("error region (",genomicRegionStr,"): end<0 or start<0 !")
    if (!(strand %in% c('+','-'))) stop("error region (",genomicRegionStr,"): strand not + or - !")
  }

  if (rt=='list') {
    return(list(chr=chr, strand=strand, start=start, end=end))
  } else {
    return(GRanges(seqnames=chr, ranges=IRanges(start, end), strand=strand))
  }
}

# .covGRregion(new('GRanges'), rt='list')
# .covGRregion(new('GRanges'), rt='gr')
# .covGRregion(list('chr1','+',1,100), rt='gr')
.covGRregion <- function(gr, rt='str') {
  if (!inherits(gr, 'GRanges') & !inherits(gr, 'list')) stop("gr is not GRanges/list!")

  if (inherits(gr, 'list')) {
    if (!is.null(names(gr))) {
      gr=GRanges(paste0(gr$chr,':',gr$start,'-',gr$end,':',gr$strand))
    } else {
      gr=GRanges(paste0(gr[[1]],':',gr[[3]],'-',gr[[4]],':',gr[[2]]))
    }
  }

  if (rt %in% c('gr','GR','GRanges','granges','ranges')) {
    if (length(gr)==0)  return(gr)
    return(gr[1])
  }

  if (rt=='str') {
    if (is.null(gr)) return(c())
    if (length(gr)==0) return(c())
    return( sprintf("%s:%s:%s:%s", as.character(seqnames(gr)[1]),
                    as.character(strand(gr)[1]),
                    start(gr)[1], end(gr)[1]) )
  }

  # others=list
  if (is.null(gr)) return(.covStrRegion(NULL, rt="list"))
  if (length(gr)==0) return(.covStrRegion(NULL, rt="list"))
  return( list(chr=as.character(seqnames(gr)[1]), strand=as.character(strand(gr)[1]), start=start(gr)[1], end=end(gr)[1]))

}


#' Get genomic regions of all genes
#'
#' getAnnoGenes retrieves genomic ranges of all genes from different genome annotation sources.
#'
#' @param annoObj An annoHub object or any ANNOTYPES.
#' @return A data frame of genomic ranges of all genes, with fixed columns of chr/strand/start/end and other columns starting with 'gene_' like gene_entrez.
#' @examples
#' library(Mus.musculus)
#' orgdb=Mus.musculus
#' genes=getAnnoGenes(orgdb)
#' @name getAnnoGenes
#' @family annotation functions
#' @export
getAnnoGenes <- function(annoObj) {

  an=annoType(annoObj)

  if (an=='orgdb') {
    genes=suppressMessages(GenomicFeatures::genes(annoObj, columns=c("SYMBOL","ENSEMBL","GENEID")))
    genes=.asDf(genes)
    colnames(genes)=c('chr','start','end','width','strand','gene_entrezid','gene_ensembl','gene_symbol')
    for (g in c('gene_entrezid','gene_ensembl','gene_symbol')) {
      genes[, g]=unlist(lapply(genes[, g], '[', 1))
    }
    return(genes[, c('chr','strand','start','end', 'gene_entrezid','gene_ensembl','gene_symbol')])
  }

  if (an=='biomart') {
    #listAttributes(bm)[grep('gene_id', listAttributes(bm)$name), ]
    genes=biomaRt::getBM(attributes = c("ensembl_gene_id", "external_gene_name", "entrezgene_id", "chromosome_name",'strand','start_position','end_position'), mart = annoObj)
    colnames(genes)=c('gene_ensembl','gene_symbol','gene_entrezid', 'chr','strand','start','end')
    genes$strand[genes$strand==1]='+'
    genes$strand[genes$strand==-1]='-'
    return(genes[, c('chr','strand','start','end', 'gene_entrezid','gene_ensembl','gene_symbol')])
  }

  cat('The function for Anno type', an, 'has not yet been realized\n')
  return(data.frame())
}


#' Get genomic regions of given genes
#'
#' getGenesRange retrieves genomic ranges of given genes from different genome annotation sources.
#'
#' @param genes A vector of gene names/symbols/ids, which could be mixed with names/symbols/ids for some annotation sources.
#' \itemize{
#' \item{TxDb}: 'genes' could only be entrezid (e.g., 9991).
#' \item{EnsDb}: 'genes' could be geneID (e.g., ENSG00000121410), gene_name (e.g., NGA3), symbol (e.g., NGA3), entrezid (e.g., 9991), but mixed is not allowed and the provided list of genes would be searched in above order.
#' \item{OrgDb}: 'genes' could be GENENAME (e.g., NGA3),SYMBOL (e.g., NGA3), ENSEMBL (e.g., ENSG00000121410), GENEID (e.g., 9991), or mixed.
#' \item{BioMart}: 'genes' could be ensembl_gene_id (e.g., ENSG00000121410), external_gene_name (e.g., NGA3), entrezgene_id (e.g., 9991), but mixed is not allowed and the provided list of genes would be searched in above order.
#' \item{genes}:  `genes` could be mixed, and will consider all columns with names containing 'gene' as gene columns.
#' \item{gff}: 'genes' could be gene_id (e.g., AT1G03987), gene_name (e.g., NGA3), or mixed.
#' }
#' @param annoObj An annoHub object or any ANNOTYPES.
#' @param rt Specify the output format, GR to output GRanges or other to output a string like 'chr:strand:start:end'. When output a string, only the first row of GRanges will be returned.
#' @return A GRanges object or a string like 'chr:strand:start:end'.
#' @examples
#' \dontrun{
#' # get gene ranges from a GFF object
#' gff <- useGff(gff ="data/Arabidopsis_thaliana.TAIR10.49.gtf")
#' getGenesRange(genes=c('AT1G03987', 'NGA3'),
#'              annoSource=new('annoHub', annos=list(gff=gff)))
#' # from a TxDb object
#' getGenesRange(genes=c('ENSG00000121410', 'cadherin 2', 'A1BG', '9991'),
#'        new('annoHub', annos=list(txdb=TxDb.Hsapiens.UCSC.hg19.knownGene)))
#' # from an EnsDb
#' getGenesRange(genes=c('ENSG00000121410', 'cadherin 2', 'A1BG', '9991'),
#'                         new('annoHub', annos=(ensdb=EnsDb.Hsapiens.v75)))
#' # from a OrgDb
#' getGenesRange(genes=c('ENSG00000121410', 'cadherin 2', 'A1BG', '9991'),
#'               new('annoHub', annos=(orgdb=Homo.sapiens)))
#' # from a Biomart object
#' bm <- useMart(biomart="plants_mart", host="https://plants.ensembl.org",
#'               dataset="athaliana_eg_gene")
#' getGenesRange(genes=c('AT1G03987', 'cadherin 2', 'A1BG', '9991'),
#'               new('annoHub', annos=(biomart=bm)))
#' # return a string
#' genesGR=getGenesRange(gene='ENSG00000121410',
#'                  new('annoHub', annos=list(orgdb=Homo.sapiens), rt='str'))
#' }
#' @name getGenesRange
#' @family annotation functions
#' @export
getGenesRange <- function(genes, annoObj, rt=c('gr','str','list')) {

  rt=validate.arg(rt, c('gr','str','list'))

  genesGR=GRanges()

  ans=names(ANNOTYPES) #txdb/gff/..

  if (inherits(annoObj, 'annoHub')) {
    if (is.empty(annoObj)) return(.covGRregion(genesGR, rt))
    defAnno=getDefaultAnno(annoObj)
    gr=getGenesRange(genes=genes, annoObj=defAnno, rt='gr')

    if (length(gr)==0 & length(annoObj)>1) {
      cat( sprintf('genes not found in defaultAnno of annoHub[ %s ], try to search other annos\n', annoObj@defaultAnno))
      for (i in ans) {
        if (i!=annoObj@defaultAnno & i %in% annoNames(annoObj)) {
          gr=getGenesRange(genes=genes, annoObj=annoObj[[i]], rt)
          if (length(gr)>0) {
            cat( sprintf('Found gene ranges in annoHub[ %d ]\n', i))
            return(gr)
          }
        }
      }
    }
    return(.covGRregion(gr, rt))
  }

  if (annoType(annoObj)=='gff') {
    #genes=c('AT1G03987', 'NGA3')
    gffGenes=annoObj$anno.frame[annoObj$anno.frame$type=='gene', c('seqnames','start','end','strand','gene_id','gene_name')]
    gffGenes=gffGenes[gffGenes$gene_id %in% genes | gffGenes$gene_name %in% genes, , drop=F]
    if (!is.null(gffGenes)) {
      if (nrow(gffGenes)>0) {
        genesGR = GenomicRanges::makeGRangesFromDataFrame(gffGenes,
                                           keep.extra.columns = TRUE)
        return(.covGRregion(genesGR, rt))
      }
    }
  }

  if (annoType(annoObj)=='genes') {
    cid=grep('gene', colnames(annoObj), fixed=TRUE)
    mms=data.frame()
    for (gc in colnames(annoObj)[cid]) { # search all gene% columns
      mm=annoObj[annoObj[,gc] %in% genes, , drop=F]
      if (nrow(mm)>0) {
        if (nrow(mms)==0) mms=mm else mms=rbind(mms, mm)
      }
    }

    if (nrow(mms)>0) {
      mms=unique(mms)
      genesGR = GenomicRanges::makeGRangesFromDataFrame(mms,
                                         keep.extra.columns = FALSE)
      return(.covGRregion(genesGR, rt))
    }
  }


  if (annoType(annoObj)=='txdb') {
    #keytypes(annoSource['txdb'])
    #columns(txdb)
    #cols <- c("TXNAME", "TXSTRAND", "TXCHROM","TXEND","TXSTART")
    #genes.tx=select(annoSource['txdb'], keys = genes, columns=cols, keytype="GENEID")
    txgenes <- GenomicFeatures::genes(annoObj, columns=c("gene_id"), filter=list(gene_id=genes))
    return(.covGRregion(txgenes, rt))
  }

  if (annoType(annoObj)=='ensdb') {
    # will search geneID, gene_name, symbol, entrezID

    # keytypes(annoSource['ensdb'])
    #genes=c('ENSG00000268020', 'ENSG00000227629')

    ensGenes=GenomicFeatures::genes(annoObj, filter = AnnotationFilter::GeneIdFilter(genes),
                   columns = c("gene_id", "gene_name", "symbol","entrezid"))

    #genes=c('DDX11L1')
    if (length(ensGenes)==0) {
      ensGenes=GenomicFeatures::genes(annoObj, filter = AnnotationFilter::GeneNameFilter(genes),
                     columns = c("gene_id", "gene_name", "symbol","entrezid"))
    }

    if (length(ensGenes)==0) {
      ensGenes=GenomicFeatures::genes(annoObj, filter = AnnotationFilter::SymbolFilter(genes),
                     columns = c("gene_id", "gene_name", "symbol","entrezid"))
    }

    #genes='100287596'
    if (length(ensGenes)==0) {
      ensGenes=GenomicFeatures::genes(annoObj, filter = AnnotationFilter::EntrezFilter(genes),
                     columns = c("gene_id", "gene_name", "symbol","entrezid"))
    }
    return(.covGRregion(ensGenes, rt))
  }

  if (annoType(annoObj)=='orgdb') {
    # genes can be "GENENAME","SYMBOL","ENSEMBL","GENEID" or mixed IDs

    #k <- head(keys(Homo.sapiens, keytype="ENTREZID"),n=3)
    #select(Homo.sapiens, keys=k, columns=c("TXNAME","SYMBOL"), keytype="ENTREZID")
    #select(annoSource['orgdb'], keys=genes, columns=c("GENENAME","SYMBOL","ENSEMBL","GENEID"), keytype="ENTREZID")
    #keytypes(Homo.sapiens); columns(Homo.sapiens)

    #genes=c('ENSG00000121410', 'cadherin 2', 'A1BG', '9991')
    #first get gene list, and then do filtering


    orgAllGenes=suppressMessages(GenomicFeatures::genes(annoObj, columns=c("GENENAME","SYMBOL","ENSEMBL","GENEID")))

    mcols=mcols(orgAllGenes)

    ## characterList, need to check if each gene is in the genes
    rowid=c()
    for (f in c("ENSEMBL","GENENAME","SYMBOL","GENEID")) {
      #rowid=c(rowid, which( lapply(which(mcols[, f] %in% genes), sum) > 0)) ## error in library:  'match' requires vector arguments
      ri=unlist(lapply( mcols[, f], function(par) sum(par %in% genes)>0 )) # T, T, F, F...
      rowid=c(rowid, which(ri))
    }

    if (length(rowid)>0) {
      rowid=unique(rowid)
      return(.covGRregion(orgAllGenes[rowid, ], rt))
    }

  }

  if (annoType(annoObj)=='biomart') {
    for (f in c("ensembl_gene_id","external_gene_name","entrezgene_id")) {
      genes.bm <- biomaRt::getBM(attributes = c("ensembl_gene_id","external_gene_name","entrezgene_id",
                                       "strand","chromosome_name", "start_position", "end_position"),
                        filters = f, values = genes,  mart = annoObj )
      if (nrow(genes.bm)>0) {
        genes.bm$strand=ifelse(genes.bm$strand==1, '+','-')
        genesGR = makeGRangesFromDataFrame(genes.bm, start.field="start_position", end.field = 'end_position',
                                           keep.extra.columns = TRUE)
        return(.covGRregion(genesGR, rt))
      }
    }
  }

  return(.covGRregion(genesGR, rt))
}



# ---------------- *** vizTracks *** ------------------

## vizTrack's theme
vizTHEME <- list(
  ### cols for stat plots
  pals=brewer.pal(8, "Set2"),
  #"#66C2A5" "#FC8D62" "#8DA0CB" "#E78AC3" "#A6D854" "#FFD92F" "#E5C494" "#B3B3B3"

  ### pars for bam cov
  bam.covMerge="No",
  bam.showMerge=FALSE,
  bam.showSingle=TRUE,
  bam.covStyle="cov", # only applicable when bam.collapse=FALSE
  bam.collapse=FALSE,

  ### bam data vis
  bams.log2=FALSE,
  bams.ysame=TRUE,
  bams.ylims=NULL, #ylimits e.g., c(10, 100) for all tracks Y-axis

  # cols for individual bams
  bams.col=brewer.pal(8, "Set2"),
  bams.fill=brewer.pal(8, "Set2"),

  # for merged bam track
  bam.covMerge.col="brown",
  bam.covMerge.fill="brown",  # for pA

  PA.col="#cf9198",
  PA.fill="#cf9198",
  PA.shape=-1, #-1(line); 0-25, tri=17
  PA.shape.size=3,

  # cols for gene model
  gm.utr5.fill="black",
  gm.utr3.fill="grey",
  gm.exon.fill="brown",  gm.line="black",

  # cols for vizCells
  cells.group.cols=c(brewer.pal(8, "Set2"), brewer.pal(8, "Set1")),
  cells.scale.low='white', cells.scale.high='black', cells.scale.mid = "darkorange",
  cells.annoBar.pos='left' #right, mid
)

## gene model without background
viz_geneModel_theme <- ggbio::theme_clear() + theme(
  panel.border=ggplot2::element_rect(colour = "grey", fill=NA),
  legend.position = "none",
  panel.grid.major = ggplot2::element_blank(),
  panel.grid.minor = ggplot2::element_blank()
)

## theme clear without Ylab and Yticks
viz_noY_theme<- ggbio::theme_clear() +
  theme(
    axis.title.y = ggplot2::element_blank(),
    axis.text.y=ggplot2::element_blank(),
    axis.ticks.y=ggplot2::element_blank(),
    panel.border=ggplot2::element_rect(colour = "grey", fill=NA),
    #legend.position = "none",
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank()
  )

## theme clear without Ylab
viz_noYLab_theme<- ggbio::theme_clear() + theme(
    axis.title.y = ggplot2::element_blank(),
    #axis.text.y=element_blank(),
    #axis.ticks.y=element_blank(),
    panel.border=ggplot2::element_rect(colour = "grey", fill=NA),
    panel.background = ggplot2::element_rect(fill = NA, color = NA),
    #legend.position = "none",
    panel.grid.major = ggplot2::element_blank(),
    panel.grid.minor = ggplot2::element_blank()
  )


#' Set the plot theme for vizTracks
#'
#' setVizTheme sets the drawing theme for vizTracks, by setting default values in vizTHEME and checking the validity.
#'
#' @param vizTheme A list similar to vizTHEME, containing the following options for plot.
#' \itemize{
#' \item{pals}: colors for stat plots, default is `brewer.pal(8, "Set2")`. Normally denotes the colors for each cell types/groups.
#'
#' \item{bam.covMerge}: for bam coverage plot, could be no/avg/sum, default is `no`. Define how to merge coverages from different cell groups.
#' \item{bam.showMerge}: for bam coverage plot, default is FALSE. Determine whether to show the bam coverage.
#' \item{bam.showSingle}: for bam coverage plot, default is TRUE. Determine whether to show each cell group in an individual track.
#' \item{bam.covStyle}: for bam coverage plot, could be cov/curve, default is `cov`. `cov` means plot coverages like area under a line, `curve` means line.
#' \item{bam.collapse}: for bam coverage plot, default is FALSE. Determine whether to collapse areas or lines of individual cell groups into one track.
#'
#' \item{bams.log2}: for bam coverage data presentation, default is FALSE, which means not to log2 the coverage value.
#' \item{bams.ysame}: for bam coverage data presentation, default is TRUE, which means set all Y-axis limit of different bam coverage tracks the same.
#' \item{bams.ylims}: for bam coverage data presentation, default is NULL. It can be set as `c(10, 100)` for all bam coverage tracks' Y-axis.
#'
#' \item{bams.col}: line colors for individual bams, default is `brewer.pal(8, "Set2")`.
#' \item{bams.fill}: filled colors for individual bams, default is, default is `brewer.pal(8, "Set2")`.
#'
#'
#' \item{bam.covMerge.col}: line color for merged bam, default is "brown".
#' \item{bam.covMerge.fill}: filled color for merged bam, default is "brown".
#'
#' \item{PA.col}: line color for a pA site, default is "#cf9198".
#' \item{PA.fill}: filled color for a pA site, default is "#cf9198".
#' \item{PA.shape}: shape for a pA site, default is `-1` (line), set 0-25 for other shapes used in geom_point.
#' \item{PA.shape.size}: size for the pA site when PA.shape is not -1, default is 3.
#'
#' \item{gm.utr5.fill}: colors for the gene model's 5'UTR, default is "black".
#' \item{gm.utr3.fill}: colors for the gene model's 3'UTR, default is"grey".
#' \item{gm.exon.fill}: colors for the exon regions, default is "brown".
#' \item{gm.line}: colors for the lines (intron), default is "black"/
#'
#' \item{cells.group.cols}: colors for the single-cell plot by vizCells, default is `c(brewer.pal(8, "Set2"), brewer.pal(8, "Set1"))`.
#' \item{cells.scale.low}: colors for low ends of the gradient, default is 'white',
#' \item{cells.scale.high}: colors for high ends of the gradient, default is 'black'.
#' \item{cells.scale.mid }: colors for mid point of the gradient, default is "darkorange".
#' \item{cells.annoBar.pos}: position for the annotation bar of cell groups, could be left (default)/right/mid.
#' }
#' @param check Whether to check the validity of values (default is TRUE).
#' @return A list.
#' @examples
#' ## print the default vizTHEME
#' setVizTheme(NULL)
#' ## modify a parameter, other parameters would be the default
#' setVizTheme(list(pals=brewer.pal(8, "Set1")), check=TRUE)
#' @name setVizTheme
#' @family vizTracks functions
#' @export
setVizTheme <- function(vizTheme, check=TRUE) {
  ## set color themes
  if (!is.null(vizTheme)) {
    if (!is.list(vizTheme)) stop("vizTheme should be a list storing cols and shapes for the track plot, see vizTHEME!")

    for (i in names(vizTHEME)) { # for pars not set in vizTheme, use the default one.
      if (!(i %in% names(vizTheme))) {
        vizTheme[[i]]=vizTHEME[[i]]
      }
    }
  } else {
    vizTheme=vizTHEME # default theme
  }

  for (i in names(vizTheme)) {
    if (is.character(vizTheme[[i]])) {
      vizTheme[[i]]=tolower(vizTheme[[i]])
    }
  }

  if (!vizTheme$bams.ysame) vizTheme$bams.ylims=NULL
  if (check) {
    if (!(vizTheme$PA.shape<=25 & vizTheme$PA.shape>=-1))
      stop("vizTheme$PA.shape should be [-1, 25]")
    if (!vizTheme$bam.covStyle %in% c('cov','curve'))
      stop("vizTheme$bam.covStyle should be either cov or curve")
    if (!vizTheme$bam.covMerge %in% c('no','avg','sum'))
      stop("vizTheme$bam.covMerge should be no/avg/sum")
    if (vizTheme$bam.covMerge=='no' & vizTheme$bam.showMerge)
      stop('vizTheme$bam.covMerge=no means not merging individual bams, then bam.showMerge should be FALSE')
    if (!vizTheme$cells.annoBar.pos %in% c('left','right'))
      stop('vizTheme$cells.annoBar.pos should be left/right')
    if (!is.null(vizTheme$bams.ylims)) {
      if (length(vizTheme$bams.ylims)!=2) stop("bams.ylims should have 2 elements, like c(2,10)")
    }
  }
  return(vizTheme)
}


#' Unify the input BAM file names
#'
#' readBAMFileNames loads BAM file names and checks the validity.
#'
#' @param bam.files A >=2 columns data frame with file name information (the first column is file name, the second is strand, third is label -- optional, the fourth is group -- optional),
#'                  or a list of file name(s) with or without file path.
#' @param bam.path File path of the bam.files.
#' @param bam.labels Short labels for each file of bam.files, default is BAM1...BAMn.
#' @param bam.groups Groups for bam.files, default is 'g1' for all bam.files.
#' @return A data frame storing BAM file information with fileName, group, label. This function will check the existence of each file (and the corresponding .bai file)!
#' @export
#' @name readBAMFileNames
#' @examples
#' ## way1: load bam file names from a dataframe
#' ## suppose there is a dataframe with three columns (filename, label, group)
#' # create three temporary bam files
#' file.create(c('f1.bam','f2.bam','c3.bam','f1.bam.bai',
#'               'f2.bam.bai','c3.bam.bai'))
#' bam.files=cbind(c('f1.bam','f2.bam','c3.bam'),
#'                c('ctrl1','ctrl2','treat1'),
#'                g=c('ctrl','ctrl','treat'))
#' readBAMFileNames(bam.files)
#' ## only provide filename, strand and label,
#' ## then the group is "g1" for all bam files
#' readBAMFileNames(bam.files[, 1:3])

#' ## way2: load bam file names from a file name list,
#' ## with all files in the current path
#' readBAMFileNames(bam.files=c('f1.bam','f2.bam','c3.bam'),
#'                  bam.labels=c('ctrl1','ctrl2','treat1'),
#'                  bam.groups=c('ctrl','ctrl','treat'))
#' # delete the created temporary bam files
#' file.remove(c('f1.bam','f2.bam','c3.bam','f1.bam.bai',
#'              'f2.bam.bai','c3.bam.bai'))

#' ## way3: load bam file names in a given Path
#' ## create 2 temporary bam files in one path
#' dir.create('_dir1')
#' file.create('_dir1/bam1.bam','_dir1/bam2.bam',
#'            '_dir1/bam1.bam.bai','_dir1/bam2.bam.bai')
#' readBAMFileNames(bam.files=c('bam1.bam', 'bam2.bam'),
#'                 bam.path='_dir1')
#' file.remove(c('_dir1/bam1.bam','_dir1/bam2.bam',
#'             '_dir1/bam1.bam.bai','_dir1/bam2.bam.bai', '_dir1'))

#' ## way4: load bam file names in different paths
#' ## create two temporary bam files in different paths
#' dir.create('_dir1'); dir.create('_dir2')
#' file.create('_dir1/bam1.bam','_dir1/bam1.bam.bai',
#'             '_dir2/bam2.bam' , '_dir2/bam2.bam.bai')
#' readBAMFileNames(bam.files=c('_dir1/bam1.bam', '_dir2/bam2.bam'),
#'                 bam.labels=c('ctrl1','ctrl2'), bam.groups=c('ctrl','ctrl'))
#' file.remove('_dir1/bam1.bam','_dir1/bam1.bam.bai', '_dir2/bam2.bam' ,
#'             '_dir2/bam2.bam.bai', '_dir1','_dir2')
#' @family vizTracks functions
readBAMFileNames<-function(bam.files, bam.path=NULL,
                           bam.labels=NULL, bam.groups=NULL) {

  if (!is.null(bam.path)) {
    if (!file.exists(file.path(bam.path))) {
      stop('bam.path= ',bam.path, ' not exists!')
    }
    bam.path=win2linuxPath(bam.path, addBar=TRUE)
  } else {
    bam.path=''
  }

  if (is.data.frame(bam.files) | is.matrix(bam.files)) {
    if (ncol(bam.files)<=1) stop('bam.files is a dataframe/matrix, should have >=1 columns (filename) +(label, group)!')
    if (ncol(bam.files)==1) {
      bam.files=bam.files[, 1]
    } else if (ncol(bam.files)==2) {
      bam.labels=bam.files[,2]
      bam.files=bam.files[,1]
    } else if (ncol(bam.files)>=3) {
      bam.labels=bam.files[,2]
      bam.groups=bam.files[,3]
      bam.files=bam.files[,1]
    }
  }

  for (i in 1:length(bam.files)) {
    if (!file.exists(paste0(bam.path, bam.files[i]))) {
      stop('bam.files= ', bam.files[i], ' not exists!')
    }
    if (!file.exists(paste0(bam.path, bam.files[i],'.bai'))) {
      stop('the .bai file (BAM index file) for ', bam.files[i], ' not exists!')
    }
    bam.files[i]=paste0(bam.path, bam.files[i]) # filename with full path
  }


  if (is.null(bam.labels)) {
    bam.labels=paste0('BAM',1:length(bam.files))
  } else {
    if (length(bam.labels)!=length(bam.files)){
      stop('length(bam.labels) not equal to length(bam.files)!')
    }
  }

  if (is.null(bam.groups)) {
    bam.groups=rep('g1', length(bam.files))
  } else {
    if (length(bam.groups)!=length(bam.files)){
      stop('length(bam.groups) not equal to length(bam.files)!')
    }
  }

  # It is possible that the BAM given by the user is located in a different path, so here fileName is the full path of the file name, removing the original filePath
  return(data.frame(fileName=bam.files, group=bam.groups, label=bam.labels))
}


## Helper to return the default biomart to feature mapping (code from gviz)
.getBMFeatureMap <- function() {
  return(list(
    gene_id = "ensembl_gene_id", transcript_id = "ensembl_transcript_id", exon_id = "ensembl_exon_id",
    start = "exon_chrom_start", end = "exon_chrom_end", rank = "rank", strand = "strand",
    symbol = c("external_gene_name"), feature = "gene_biotype", chromosome = "chromosome_name",
    u5s = "5_utr_start", u5e = "5_utr_end", u3s = "3_utr_start", u3e = "3_utr_end", cdsl = c("cds_start"),
    phase = "phase"
  ))
}


#' Get gene model track
#'
#' getTrackGeneModel retrieves a gene model track from a given gene or a genomic range, based on different annotation sources.
#'
#' @param genomicRegion A string with four fields describing a genomic region, like 1:-:1000:100000'.
#' @param gene A gene name, gene symbol, or gene id'.
#' @param annoSource An annoHub object, the defaultAnno would be used to get gene models. If is.empty, then use the genomicRegion as axis.
#' @param title Title of the track, default is genemodel.
#' @param vizTheme A vizTHEME-like list to specify the theme of the track.
#' @return A track of the gene model.
#' @examples
#' \dontrun{
#' # get track from a genomic region
#' gff <- useGff(gff ="data/Arabidopsis_thaliana.TAIR10.49.gtf")
#' getTrackGeneModel(genomicRegion='1:-:1000:100000',
#'                annoSource=new("annoHub", annos=list(gff=gff)))
#' getTrackGeneModel(genomicRegion='chr1:-:1000:100000',
#'                   annoSource=new("annoHub",
#'                       annos=list(txdb=TxDb.Hsapiens.UCSC.hg19.knownGene)))
#' getTrackGeneModel(genomicRegion='1:-:1000:100000',
#'            annoSource=new("annoHub", annos=list(ensdb=EnsDb.Hsapiens.v75)))
#' getTrackGeneModel(genomicRegion='chr1:-:1000:100000',
#'          annoSource=new("annoHub", annos=list(orgdb=Homo.sapiens)))
#' bm <- useMart(biomart="plants_mart",
#'           host="https://plants.ensembl.org", dataset="athaliana_eg_gene")
#' getTrackGeneModel(genomicRegion='1:+:500000:520000',
#'                   annoSource=new("annoHub", annos=list(biomart=bm)))
#' # get track from a gene
#' getTrackGeneModel(gene='AT1G01200',
#'                      annoSource=new("annoHub", annos=list(biomart=bm)))
#' # we can also get the genomic range of a gene first
#' gr=getGenesRange(genes=c('AT1G01200'),
#'                 annoSource=new("annoHub", annos=list(biomart=bm), rt='str'))
#' # and then get the gene model track
#' getTrackGeneModel(genomicRegion=gr,
#'                  annoSource=new("annoHub", annos=list(biomart=bm)))
#' }
#' @name getTrackGeneModel
#' @family vizTracks functions
#' @export
getTrackGeneModel <- function(genomicRegion=NULL,
                              gene=NULL,
                              annoSource=new("annoHub"),
                              title='genemodel', vizTheme=NULL) {

  VT=setVizTheme(vizTheme)

  if (is.null(genomicRegion) & is.null(gene)) stop("Please specify genomicRegion or gene for getTrackGeneModel!")
  if (!is.null(genomicRegion) & !is.null(gene)) stop("Please specify genomicRegion or gene (not both!) for getTrackGeneModel!")

  ## If the gene is provided, first exhaustively annoSource to obtain the gene interval
  if (!is.null(gene)) {
    regionGR=getGenesRange(genes=gene, annoObj=annoSource)
    if (length(regionGR)>1) {
      cat("Found more than one ranges for gene",gene,", only use the first range to get gene model track.")
      regionGR=regionGR[1, ]
    }
    if (length(regionGR)==0) stop("getTrackGeneModel: No genomic range from gene: ",gene,"!")
    regionLst=list(chr=as.character(seqnames(regionGR)[1]), strand=as.character(strand(regionGR)[1]), start=start(regionGR)[1], end=end(regionGR)[1])
  } else {
    regionGR <- .covStrRegion(genomicRegion, rt='gr')
    regionLst <- .covStrRegion(genomicRegion, rt='list')
  }

  if (!is.empty(annoSource)) {
    givenChr=regionLst$chr
    annoChrs=getAnnoChrs(annoSource)
    # chr not consistent, use chrMappings to get mapped chr name in the provided data
    if (!(givenChr %in% annoChrs)) {
      if (nrow(annoSource@chrMappings)==0)
        stop ("chr of genomicRegion [", givenChr, "] is not in defaultAnno of annoSource ",annoSource@defaultAnno," , please make them consistent first or provide annoSource@chrMappings!\n")

      cat( sprintf("chr of genomicRegion [ %s ] is not in annoHub [ %s ], try to use annoSource@chrMappings to cooridnate chrs.\n",
                   givenChr, annoSource@defaultAnno) )

      chrMaps=annoSource@chrMappings

      newChr=getMappedChr(givenChr, annoChrs, chrMaps, must=TRUE)
      if (newChr!=givenChr)
        cat( sprintf("New chr mapping of annoHub [ %s ]: %s --> %s \n",
                     annoSource@defaultAnno, givenChr, newChr ) )
      if (length(newChr)!=1) stop("chr of genomicRegion [", givenChr, "] not found in annoHub")

      regionLst$chr=newChr
      regionGR=.covGRregion(regionLst, rt='gr')
    }
  }

  if (length(regionGR)==0) stop("getTrackGeneModel: No genomic range from genomicRegion or gene!")

  tks=list()
  pg=NULL

  ## gene model track
  if (is.empty(annoSource)) {
    # no annoSource, use the genomicRegion as axis
    geneGR = regionGR
    mcols(geneGR)$model='exon'
    ##!!!! must add GenomicRanges::, otherwise return a list class, error raised!
    geneGR=GenomicRanges::split(geneGR)
    pg=ggbio::autoplot(geneGR, aes(type = model),  exon.rect.h=0.5,
                       color = vizTHEME$gm.exon.fill, fill = vizTHEME$gm.exon.fill) +
      viz_geneModel_theme

  } else if (annoSource@defaultAnno=='gff') {

    # anno=parseGff's result
    geneGR = regionLst
    txdb=annoSource['gff']
    txdb=txdb$anno.need
    txdb=txdb[txdb$seqnames==geneGR$chr & txdb$strand==geneGR$strand, ]

    txdbGR=GRanges(seqnames=txdb$seqnames, ranges=IRanges(txdb$start, txdb$end),
                   strand=txdb$strand, mcols=txdb)
    annoGene=subsetByOverlaps(txdbGR, regionGR, ignore.strand=FALSE, type='any')

    annoGene=.asDf(annoGene)
    annoGene$mcols.type[annoGene$mcols.type=='intron']='gap' #only can shown utr/cds/exon/gap
    annoGene$mcols.type[annoGene$mcols.type=='CDS']='cds' #only can shown utr/cds/exon/gap
    annoGene$mcols.type[annoGene$mcols.type %in% c('5UTR','3UTR', 'three_prime_UTR','five_prime_UTR')]='utr'
    annoGene=annoGene[annoGene$mcols.type %in% c('utr','gap','cds','exon'), ]
    geneGR= GRanges(seqnames =annoGene$seqnames ,
                    ranges =IRanges(start=as.integer(annoGene$start) ,
                                    end=as.integer(annoGene$end)),
                    strand =as.character(annoGene$strand),
                    transcript=annoGene$mcols.Parent, model=annoGene$mcols.type)

    geneGR=GenomicRanges::split(geneGR, mcols(geneGR)$transcript) #Must convert to glist for each transcript, even only 1 transcript

    if (length(geneGR)==0) {
      pg=NULL
    } else {
      pg=ggbio::autoplot(geneGR, aes(type = model),
                         label.color = "black", color = VT$gm.exon.fill, fill = VT$gm.exon.fill) +
        viz_geneModel_theme
    }
  } else if (annoSource@defaultAnno=='txdb') {
    ## Make gene model from TxDb object

    # # get gene ranges
    # txgenes <- genes(annoSource['txdb'], columns=c("tx_type","gene_id"))
    # # filter genes in the GR
    # txgenes=subsetByOverlaps(txgenes, regionGR, ignore.strand=FALSE, type='any')
    # if (length(txgenes)>0) {
    #   pg=ggbio::autoplot(annoSource['txdb'], which=txgenes , names.expr = "gene_id")
    # }

    ## The GR can be plot by ggbio::autoplot(annoSource['txdb'], which=regionGR)
    pg=ggbio::autoplot(annoSource['txdb'], which=regionGR,
                       label.color = "black", color = VT$gm.exon.fill, fill = VT$gm.exon.fill) +
      viz_geneModel_theme

  } else if (annoSource@defaultAnno=='ensdb') {
    ## Make gene model from EnsDb object
    #library('AnnotationFilter'); library('EnsDb.Hsapiens.v75')
    #annoSource['ensdb']=EnsDb.Hsapiens.v75
    pg=ggbio::autoplot(annoSource['ensdb'], AnnotationFilter::GRangesFilter(regionGR, "any"), names.expr = "gene_name",
                       label.color = "black", color = VT$gm.exon.fill, fill = VT$gm.exon.fill) +
      viz_geneModel_theme
  } else if (annoSource@defaultAnno=='orgdb') {
    ## Make gene model from OrganismDb object
    #library(Homo.sapiens)
    #annoSource['orgdb']=Homo.sapiens
    msg=testthat::capture_messages( pg<-ggbio::autoplot(annoSource['orgdb'], regionGR,
                                                        label.color = "black", color = vizTHEME$gm.exon.fill, fill = vizTHEME$gm.exon.fill) +
                                      viz_geneModel_theme
    )
    ## If no result is found, pg will error and cannot determine null, only message can be captured
    if ("No transcripts found at this region.\n" %in% msg) pg=NULL

  }  else if (annoSource@defaultAnno=='biomart') {
    ## Make gene model from biomart object -- by gviz
    ## code modified from gviz::.fetchBMData()
    ## only retain the UTR feature and change other features to exon
    featureMap <- .getBMFeatureMap()
    regionLst2=regionLst
    regionLst2$strand=ifelse(regionLst2$strand=='-', '-1', '1')
    #regionLst2=list(chr=1, strand=-1, start=86486, end=88409)
    ens <- biomaRt::getBM(unlist(featureMap),
                 filters = c('chromosome_name', 'strand','start','end'),
                 values = regionLst2, bmHeader = FALSE, mart = annoSource['biomart'], uniqueRows = TRUE
    )

    colnames(ens) <- names(featureMap)

    ## Only those transcripts that have a CDS length will be considered protein_coding
    ens$feature <- ifelse(is.na(ens$cdsl) & ens$feature == "protein_coding", "non_coding", ens$feature)
    ## We may have to split exons if they contain UTRs
    hasUtr <- !is.na(ens$u5s) | !is.na(ens$u3s)
    ensUtr <- ens[hasUtr, , drop = FALSE]
    ensUtr$ffeature <- ifelse(is.na(ensUtr$u5s), "utr3", "utr5")
    ensUtr$us <- ifelse(ensUtr$ffeature == "utr3", ensUtr$u3s, ensUtr$u5s)
    ensUtr$ue <- ifelse(ensUtr$ffeature == "utr3", ensUtr$u3e, ensUtr$u5e)
    ensUtr$u5e <- ensUtr$u5s <- ensUtr$u3e <- ensUtr$u3s <- NULL
    allUtr <- ensUtr$us == ensUtr$start & ensUtr$ue == ensUtr$end
    utrFinal <- ensUtr[allUtr, , drop = FALSE]
    ensUtr <- ensUtr[!allUtr, , drop = FALSE]
    ensUtrS <- GenomicRanges::split(ensUtr, ifelse(ensUtr$start == ensUtr$us, "left", "right"))

    if (length(ensUtrS)>0) {
      utrFinal <- rbind(utrFinal, do.call(rbind, lapply(names(ensUtrS), function(i) {
        y <- ensUtrS[[i]]
        if (nrow(y) == 0) {
          return(NULL)
        }
        yy <- y[rep(seq_len(nrow(y)), each = 2), ]
        sel <- seq(1, nrow(yy), by = 2)
        yy[sel, "end"] <- if (i == "left") yy[sel, "ue"] else yy[sel, "us"] - 1
        yy[sel, "ffeature"] <- yy[sel, ifelse(i == "left", "ffeature", "feature")]
        yy[sel, "phase"] <- if (i == "left") -1 else 0
        sel <- seq(2, nrow(yy), by = 2)
        yy[sel, "start"] <- if (i == "left") yy[sel, "ue"] + 1 else yy[sel, "us"]
        yy[sel, "ffeature"] <- yy[sel, ifelse(i == "left", "feature", "ffeature")]
        yy[sel, "phase"] <- if (i == "left") yy[sel, "phase"] else -1
        yy
      })))

      utrFinal$feature <- utrFinal$ffeature
      keep <- c(
        "gene_id", "transcript_id", "exon_id", "start",
        "end", "rank", "strand", "symbol", "feature",
        "chromosome", "phase"
      )
      ens <- rbind(ens[!hasUtr, keep, drop = FALSE], utrFinal[, keep])
    }

    ens$feature[ens$feature %in% c('utr5','utr3')]='utr' #only can shown utr/cds/exon/gap
    ens$feature[!(ens$feature %in% c('utr'))]='exon'

    geneGR <- GRanges(
      seqnames = ens$chromosome,
      ranges = IRanges(start = ens$start, end = ens$end),
      strand = ens$strand, model = as.character(ens$feature),
      gene = as.character(ens$gene_id), exon = as.character(ens$exon_id),
      transcript = as.character(ens$transcript_id)
    )
    geneGR <- sort(geneGR)
    geneGR=GenomicRanges::split(geneGR, mcols(geneGR)$transcript) #Must convert to glist for each transcript, even only 1 transcript

    if (length(geneGR)>0) {
      pg=ggbio::autoplot(geneGR, aes(type = model),
                         label.color = "black", color = VT$gm.exon.fill, fill = VT$gm.exon.fill) +
        viz_geneModel_theme
    }
  }

  if (is.null(pg)) {
    cat("Cannot find gene models from annoHub [",annoSource@defaultAnno,"], only show the whole genomic region!\n")
    geneGR = regionGR
    mcols(geneGR)$model='exon'
    geneGR=GenomicRanges::split(geneGR)
    pg=ggbio::autoplot(geneGR, aes(type = model),  exon.rect.h=0.5,
                       color = vizTHEME$gm.exon.fill, fill = vizTHEME$gm.exon.fill) + viz_geneModel_theme
  }

  tks[[title]]=pg

  return(tks)
}

#' Subset a PACdataset and convert to GRanges
#'
#' subsetPACds2GR subsets a PACdataset by a genomic region, gene id/name/symbol, or pA ids, and converts the result into GRanges.
#'
#' @param PACds A PACdataset object.
#' @param genomicRegion A string with four fields describing a genomic region, like 1:-:1000:100000.
#' @param gene A gene name corresponding to the gene column in PACds@anno.
#' @param PAs A vector of pA ids corresponding to the rownames of PACds@counts.
#' @param PA.columns A string denoting the column name of the pA coordinates (e.g., coord) or the pA ranges (e.g., UPA_start:UPA_end).
#' @param PA.width If PA.columns is a position (e.g., coord), then the pA range can be expanded by PA.width to be visualized more clearly in the track plot.
#'                 For example, if PA.width=10, then the pA position would be converted to a range of 2*PA.width+1 with the pA in the center.
#' @param mcols Extra columns from PACds@anno or PACds@counts to keep as mcols in the final GRange object.
#'              This could be useful when extracting expression values of the PACds for the track plot.
#' @return A GRanges object contains extra columns of coord (the end of a pA range if PA.columns like start:end) and mcols.
#' @examples
#' # subset PACds in the given region and
#' # add the "tot_tagnum" column (should be in PACds@anno or PACds@counts) to the returned GR object.
#' data(scPACds)
#' subsetPACds2GR(scPACds, genomicRegion='chr1:+:1000:10000', mcols=c('tot_tagnum'))
#' @name subsetPACds2GR
#' @family vizTracks functions
#' @export
subsetPACds2GR<-function(PACds,
                         genomicRegion=NULL,
                         gene=NULL,
                         PAs=NULL,
                         PA.columns="coord", PA.width=10,
                         mcols=NULL) {

  # convert PA's start:end type to start/end
  PA.columns<-unlist(strsplit(PA.columns,":",fixed=T))

  if (length(PA.columns)==1) { # like coord
    if (!(PA.columns %in% colnames(PACds@anno))) stop('PA.columns not in the column names of PACds@anno')
    PACds@anno$start=PACds@anno[, PA.columns]-PA.width
    PACds@anno$end=PACds@anno[, PA.columns]+PA.width
    PACds@anno$start[PACds@anno$start<=0]=1
    PACds@anno$coord=PACds@anno[, PA.columns] # keep coord to plot the value track
  } else { # like start:end
    if (length(PA.columns)!=2) stop("PA.columns should be like coord (for a single coordinate) or start:end (for a range)")
    if (!AinB(PA.columns, colnames(PACds@anno))) stop('PA.columns: ',paste(PA.columns, collapse = ','),' not in the column names of PACds@anno')
    PACds@anno$start=PACds@anno[, PA.columns[1]]
    PACds@anno$end=PACds@anno[, PA.columns[2]]
    PACds@anno$coord=PACds@anno$end
    PACds@anno$coord[PACds@anno$strand=='-']=PACds@anno$start[PACds@anno$strand=='-'] ## if the PA is represented by start-end then the PA coord is END.
  }

  ## add mocols to GR
  if (!is.null(mcols)) {
    for (m in mcols) {
      if (!(m %in% colnames(PACds@anno))) {
        if (m %in% colnames(PACds@counts)) {
          PACds@anno=cbind(PACds@anno, PACds@counts[, m])
          colnames(PACds@anno)[ncol(PACds@anno)]=m
        } else {
          stop("mcols ", m," not in PACds@anno or PACds@counts!")
        }
      }
    }
  }

  if (!is.null(genomicRegion)) {
    PACds=movAPA::subsetPACds(PACds, chrs=.covStrRegion(genomicRegion)$chr)
    regionGR=.covStrRegion(genomicRegion, rt = 'gr')
    PACdsGR <- makeGRangesFromDataFrame(PACds@anno, keep.extra.columns = TRUE)
    PACdsGR=subsetByOverlaps(PACdsGR, regionGR, ignore.strand=FALSE, type='any')

  } else if (!is.null(gene)) {
    PACds=movAPA::subsetPACds(PACds, genes=gene)
    PACdsGR <- makeGRangesFromDataFrame(PACds@anno, keep.extra.columns = TRUE)

  } else if (!is.null(PAs)) {
    PACds=movAPA::subsetPACds(PACds, PAs=PAs)
    PACdsGR <- makeGRangesFromDataFrame(PACds@anno, keep.extra.columns = TRUE)
  }

  return(PACdsGR)
}

#' Get the pA track
#'
#' getTrackPACds gets the plot track(s) for a PACdataset.
#'
#' @param PACds A PACdataset object.
#' @param genomicRegion A string with four fields describing a genomic region, like 1:-:1000:100000.
#' @param gene A gene name corresponding to the gene column in PACds@anno.
#' @param PAs A vector of pA ids (rownames of PACds@counts).
#' @param log TRUE to log2(PACds@counts+1) applicable when PA.show to show tag not pos.
#' @param PA.show A vector describing the information of pA to extract, e.g., PA.show=c('pos','tag').
#'                  PA.show=pos means extracting the coordinates of pAs; other values (e.g., tag, tot_tagnum) should be the column in PACds@anno or PACds@counts denoting the expression level of pAs.
#' @param PA.columns A string denoting the pA coordinates (e.g., coord) or ranges (e.g., UPA_start:UPA_end).
#' @param PA.width If PA.columns is a position (e.g., coord), then the pA range can be expanded by PA.width to be visualized more clearly in the track plot.
#'                 For example, if PA.width=10, then the pA position would be converted to a range of 2*PA.width+1 with the pA in the center.
#' @param title Title for the track, should be the same length as PA.show.
#' @param vizTheme a vizTHEME-like list to specify the theme of the track.
#' @return One or more tracks of pAs This function first subsets PACds by genomie region or gene name or pA ids, and retrieves the pA information (coordinates and/or expression values) according to PA.show. The number of tracks is equal to the length of PA.show.
#'         The bar width of each pA depends on PA.columns and/or PA.width. If PA.columns is like 'coord' then the bar width is 2*PA.width+1; if PA.columns is like 'start:end', then the bar width of a pA is end-start+1 of the respective pA.
#' @examples
#' data(scPACds)
#' tk=getTrackPACds(scPACds, genomicRegion='1:+:1000:10000', PA.show=c("pos","tag"),
#'              PA.columns="coord", PA.width=10)
#' @name getTrackPACds
#' @family vizTracks functions
#' @export
getTrackPACds <- function(PACds, genomicRegion=NULL,
                          gene=NULL,
                          PAs=NULL,
                          PA.show=c("pos"), log=FALSE,
                          PA.columns="coord", PA.width=NULL, title=NULL, vizTheme=NULL) {

  VT=setVizTheme(vizTheme)
  tcks=list()

  # if(grepl('tri', VT$PA.shape)) {
  #   if (length(PA.columns)!=1) {
  #     cat('PA.columns is not a single position, but vizTheme$PA.shape is triangle, use box-shape for PA\n')
  #     VT$PA.shape='box'
  #   }
  # }

  if (is.null(PA.show)) PA.show=c('pos')

  if (!is.null(title)) {
    if (length(title)!=length(PA.show)) stop("getTrackPACds: title should be the same length as PA.show!")
  }

  mcols=NULL
  for (i in 1:length(PA.show)) {
    if (tolower(PA.show[i])!='pos') {
      mcols=c(mcols, PA.show[i])
    }
  }

  if (!AinB(PA.show, 'pos') & log) PACds=logPACds(PACds)

  cat(genomicRegion, '\n')
  PACdsGR=subsetPACds2GR(PACds, genomicRegion=genomicRegion, gene=gene,
                         PAs=PAs, PA.columns=PA.columns, PA.width=PA.width, mcols=mcols)

  if (length(PACdsGR)>0) {
    PACdf=.asDf(PACdsGR)

    for (i in 1:length(PA.show)) {
      if (tolower(PA.show[i])=='pos') { ## plot PA position

        if (VT$PA.shape==-1) { # lines
          PACdsGR=GenomicRanges::split(PACdsGR, 1:length(PACdsGR))
          tck=ggbio::autoplot(PACdsGR, color = VT$PA.col, fill = VT$PA.fill) +
            viz_geneModel_theme
        } else { #other shapes
          pas=mcols(PACdsGR)$coord
          tck=ggplot(PACdf,aes(x=pas, y=0)) +
            geom_point(shape=VT$PA.shape, size=VT$PA.shape.size, color=VT$PA.col) +
            ylim(0, 0) + viz_noY_theme
        }

      } else { ## plot PA values: mcols=PA.show[[i]]
        valueColumn=PA.show[i]
        tck <- ggplot(PACdf, aes(x=coord, xend=coord, y=0, yend=.data[[valueColumn]]))+
          ggplot2::geom_segment(linewidth=1, col=VT$PA.col) + viz_noYLab_theme
      }
      tcks[[length(tcks)+1]]=tck
    }
  } else {
    cat('No PAs of the PACds in the plot-region, the PA-track is not shown!\n')
  }
  if (!is.null(title) & length(tcks)>0) names(tcks)=title
  return(tcks)
}


#' Get the BAM track
#'
#' getTrackBams gets the plot track(s) for a BAM file list.
#'
#' @param bams A dataframe describing the BAM file list. See the output of readBAMFileNames().
#' @param genomicRegion A string with four fields describing a genomic region, like 1:-:1000:100000. The BAM coverages on the same strand in the BAM file will be extracted.
#' @param vizTheme a vizTHEME-like list to specify the theme of the track.
#' @return Tracks of BAM coverages. This function first subsets BAM coverages in the given genomic region and returns the track in different styles based on vizTheme.
#'         The number of tracks depends on vizTheme. The tracks can be individual conditions (cell types), merged data (AVG or SUM), or collapsed coverages. The colors of bams set in vizTheme$bams.col are as the order in the bams list.
#' @examples
#' \dontrun{
#' tk=getTrackBams(bams, genomicRegion='1:+:1000:10000', vizTheme=vizTheme)
#' }
#' @name getTrackBams
#' @family vizTracks functions
#' @export
getTrackBams <- function(bams, genomicRegion, vizTheme=NULL) {

  VT=setVizTheme(vizTheme)

  regionLst <- .covStrRegion(genomicRegion, rt='list')
  regionGR <- .covStrRegion(genomicRegion, rt='gr')

  ## get the cov dataframe with coordinates and cov of each bam
  ## like [start seqnames strand  end Columella Cortex Endodermis]
  coverage.data<- data.frame(start=c(regionLst$start:regionLst$end))
  coverage.data$seqnames <- regionLst$chr
  coverage.data$strand <- regionLst$strand
  coverage.data$end <- coverage.data$start

  tks=list()

  if (0) { # old: read strand-specific bams, but it is wrong when read non-strand-specific bam
    for(i in 1:length(bams$fileName)){
      bampath=bams$fileName[i]
      #bf<-Rsamtools::BamFile(bampath)
      covSigs <- bamsignals::bamCoverage(bampath, regionGR, verbose=FALSE)
      # plot(x=1:length(covSigs@signals[[1]]), y=covSigs@signals[[1]], type='h')
      coverage.data <- cbind(coverage.data, covSigs)
      colnames(coverage.data)[ncol(coverage.data)]= bams$label[i]
    }
  }

  for(i in 1:length(bams$fileName)){

    bampath=bams$fileName[i]
    p1 <- Rsamtools::ScanBamParam(what=c("strand", "pos", "qwidth"), which=regionGR)
    res <- .asDf(Rsamtools::scanBam(bampath, param=p1)[[1]])
    res$strand=as.character(res$strand)

    #filter out the other strand
    res=res[res$strand==regionLst$strand, , drop=F]

    if (nrow(res)>0) {
      covSigs=IRanges::coverage(IRanges(res[["pos"]], width=res[["qwidth"]]))
      covSigs=as.vector(covSigs)[regionLst$start:regionLst$end]
      covSigs[is.na(covSigs)]=0
    } else {
      covSigs=0
    }

    coverage.data <- cbind(coverage.data, covSigs)
    colnames(coverage.data)[ncol(coverage.data)]= bams$label[i]
  }

  #plot(x=1:length(coverage.data$Columella), y=coverage.data$Columella, type='h')

  # if(regionLst$strand=="-"){
  #   coverage.data$start<-rev(coverage.data$start)
  #   coverage.data$end<-rev(coverage.data$end)
  # }

  if(VT$bams.log2) {
    coverage.data[, bams$label]=log2(coverage.data[, bams$label]+1)
  }

  if(VT$bam.collapse){ # plot curves/covs of all conditions in one track, but with separate curves

    coverage.data.use <- coverage.data %>% tidyr::pivot_longer(cols=bams$label, names_to = c("conds"), values_to = "Coverage")

    coverage.track <- ggplot(data=coverage.data.use, aes(x=start, y=Coverage, group=conds, col=conds)) +
      geom_line(linewidth=1.5) + scale_colour_manual(values = VT$bams.col) + viz_noYLab_theme

    tks[['collapse']] <- coverage.track

  } else { # not bam.collapse: plot each bam in one track

    # the same Y-axis for all tracks
    if (VT$bams.ysame) {
      if (is.null(VT$bams.ylims)) {
        VT$bams.ylims=c(min(coverage.data[, bams$label], na.rm = TRUE), max(coverage.data[, bams$label], na.rm = TRUE))
      }
    } else {
      VT$bams.ylim=NULL
    }

    VT$bams.col=rep(VT$bams.col, length.out=length(bams$fileName))
    VT$bams.fill=rep(VT$bams.fill, length.out=length(bams$fileName))

    if (VT$bam.showSingle) { #  will plot tracks for individual conds
      for(i in 1:length(bams$fileName)){

        if(VT$bam.covStyle=="curve"){
          coverage.track <- ggplot(coverage.data, aes(start, .data[[bams$label[i]]])) +
            geom_line( linewidth=1.5, col=VT$bams.col[i])  + viz_noYLab_theme
        } else if(VT$bam.covStyle=="cov"){
          # coverage.track <- coverage.track  + geom_area(fill = VT$bams.col[i]) ## plot area under curve, slow!
          # plot verticle lines, quick!
          coverage.track <- ggplot(coverage.data, aes(x=start,xend=start,y=0,yend=.data[[bams$label[i]]]))+
            ggplot2::geom_segment(linewidth=1, col=VT$bams.col[i])  + viz_noYLab_theme
        }

        if (!is.null(VT$bams.ylim)) coverage.track = coverage.track + ylim(VT$bams.ylims[1], VT$bams.ylims[2])

        tks[[bams$label[i]]] <- coverage.track

      }
    }
  }

  # covMerge: add AVG and SUM column
  cname='AVG'
  if(nrow(bams)>1 & VT$bam.covMerge =="avg"){
    coverage.data$AVG=rowMeans(coverage.data[, bams$label, drop=F])
  }

  if(nrow(bams)>1 & VT$bam.covMerge=="sum"){
    coverage.data$SUM=rowSums(coverage.data[, bams$label, drop=F])
    cname='SUM'
  }

  if(nrow(bams)>1 & VT$bam.showMerge) {
    coverage.track  <- ggplot(coverage.data, aes(start, .data[[cname]])) +
      geom_line( linewidth=1.5, col=VT$bam.covMerge.col)  + viz_noYLab_theme

    if(VT$bam.covStyle=="cov"){
      coverage.track <- coverage.track  + geom_area(fill = VT$bam.covMerge.col)
    }
    tks[['mergedCov']] <- coverage.track
  }

  return(tks)
}


## code from millefy's millefy-track.R
orderWithinGroups <- function(values, groups){
  unlist(as.vector(mapply(function(x,y){y[order(x, decreasing = T)]}, split(values, groups), split(seq_along(values), groups))))
}

runDiffusionMap<- function(mat){

  matOld=mat

  sel_danger <- (rowSums(mat) == 0)
  sel <- !sel_danger
  mat=matOld[sel, , drop=F]

  e <- try({
    dif <- destiny::DiffusionMap(destiny::as.ExpressionSet(.asDf(mat)));
    cat(sprintf("Eigenvalue of DC1: %f\n", destiny::eigenvalues(dif)[1]));
    res <- dif@eigenvectors[, "DC1"];
  }, silent=TRUE)

  if(inherits(e, "try-error")) {
    #warning("There was a problem when running diffusion map. Trying PCA instead...\n")
    e <- try({
      pca =  stats::prcomp(log10(mat+1),
                    center = TRUE,
                    scale. = TRUE);
      #cat(sprintf("The standard deviations of PC1: %f\n", pca$sdev[1]));
      res <- pca$x[, "PC1"];
    }, silent=TRUE)

    if(inherits(e, "try-error")) {
      res <- rep(1, nrow(mat))
    }
  }

  dc1 <- numeric(nrow(matOld))
  dc1[sel] <- res
  dc1[!sel] <- dc1[which(sel_danger)[1]]

  return(dc1)
}


#' Get the track of pA in individual cells
#'
#' getTrackCells gets the track of pA/gene ratios or counts in individual cells
#'
#' @param PACds A PACdataset object.
#' @param genomicRegion A string with four fields describing a genomic region, like 1:-:1000:100000.
#' @param gene A gene name corresponding to the gene column in PACds@anno.
#' @param PAs A vector of pA ids (rownames of PACds@counts).
#' @param group The column name recording cell categories in PACds@colData.
#' @param sortMethod To set the method for ordering cells, sum (using the sum of all pAs) (default), or diffusion (using diffusion map to order cells -- see Millefy Package).
#' @param sortCells To sort cells within group (group) or without group (all), or not sort (none, default).
#' @param log TRUE to log2(1+PACds@counts) for count-type PACds.
#' @param PA.columns A string denoting the pA coordinates (e.g., coord) or ranges (e.g., UPA_start:UPA_end).
#' @param PA.width If PA.columns is a position (e.g., coord), then the pA range can be expanded by PA.width to be visualized more clearly in the track plot.
#'                 For example, if PA.width=10, then the pA position would be converted to a range of 2*PA.width+1 with the pA in the center.
#' @param annoCoord The position to put the annotation bar of cell groups, only used when group is not NULL.
#' @param title Title of the track.
#' @param vizTheme a vizTHEME-like list to specify the theme of the track.
#' @return One track to show pA counts or ratios in individual cells. The bar width of each pA depends on PA.columns and/or PA.width. If PA.columns is like 'coord' then the bar width is 2*PA.width+1; if PA.columns is like 'start:end', then the bar width of a pA is end-start+1 of the respective pA.
#' @examples
#' \dontrun{
#' sc.tk1=getTrackCells(PACds,gene=gene,
#' group='celltype', sortMethod='sum', sortCells='group',log=TRUE,
#' PA.columns="coord", PA.width=100,title='diffs')
#' }
#' @name getTrackCells
#' @family vizTracks functions
#' @export
getTrackCells <- function(PACds,
                          genomicRegion=NULL,
                          gene=NULL,
                          PAs=NULL,
                          group=NULL,
                          sortMethod=c('sum','diffusion'), sortCells=c('none', 'all','group'),
                          log=FALSE, PA.columns="coord", PA.width=100,
                          annoCoord=NULL, title='cells', vizTheme=NULL) {

  sortCells = validate.arg(sortCells, c('none', 'all','group'))
  sortMethod = validate.arg(sortMethod, c('sum','diffusion'))

  legendLab='cell'
  if (log) {
    c1=PACds@counts
    PACds=logPACds(PACds)
    if (!identical(c1, PACds@counts)) legendLab='logVal'
  }

  if (is.null(group)) {
    if (sortCells=='group') stop("group=NULL, sortCells should be none/all!")
  }

  VT=setVizTheme(vizTheme)
  tcks=list()

  if (!is.null(group)) {
    if (!(group %in% colnames(PACds@colData))) stop('group not in PACds@colData!')
    groups <- as.character(PACds@colData[, group])
  } else {
    groups=rep('Cells', ncol(PACds@counts)) # all cells in one group
  }

  groupColors <- VT$cells.group.cols
  ngroup=length(unique(groups))

  if (length(groupColors)<ngroup) groupColors=rep_len(groupColors, ngroup)
  groupColors=groupColors[1:ngroup]

  if (is.null(names(groupColors))) names(groupColors)=unique(groups)

  PACdsGR=subsetPACds2GR(PACds, genomicRegion=genomicRegion, gene=gene,
                         PAs=PAs, PA.columns=PA.columns, PA.width=PA.width)

  if (length(PACdsGR)>0) {

    PACdf=t(PACds@counts[names(PACdsGR), , drop=F])

    PACdf[is.na(PACdf)] <- 0
    min_value <- min(PACdf)
    max_value <- max(PACdf)
    mid=mean(c(min_value, max_value))

    if (sortMethod=='diffusion') {
      dc= suppressMessages(runDiffusionMap(PACdf))
    } else {
      dc=rowSums(PACdf)
    }
    ## order cells by dc values
    if(sortCells == 'all'){
      neworder <- order(dc, decreasing = T)
      PACdf <- PACdf[neworder, , drop=F]
    }else if(sortCells == 'group' & ngroup>1){
      neworder <- orderWithinGroups(dc, groups)
      PACdf <- PACdf[neworder, , drop=F]
    }

    rasterDf=.asDf(PACdf)
    for (i in 1:length(PACdsGR)) { # PA1..PAn
      start=start(PACdsGR)[i]
      end=end(PACdsGR)[i]
      d1=.asDf(PACdf[, i, drop=F])
      colnames(d1)='PA'
      d1$y=1:nrow(PACdf) # Y is the row (cell) id
      d1$x1=start
      d1$x2=end
      if (i==1) {
        rasterDf=d1
      } else {
        rasterDf=rbind(rasterDf, d1)
      }
    }

    if (ngroup>1) { # with legend of cells
      PAwidth=width(PACdsGR)[1]

      ## set the position of the annobar
      if (!is.null(annoCoord)) {
        x1=annoCoord
      } else {
        PAgap=5*PAwidth
        PAstart=min(start(PACdsGR))
        PAend=max(end(PACdsGR))
        # make the start/end of the region is far from the PA
        if (!is.null(genomicRegion)) {
          regionGR=.covStrRegion(genomicRegion, rt = 'list')
          rgStart=regionGR$start
          rgEnd=regionGR$end
          if (rgStart>PAstart-PAgap) rgStart=PAstart - PAgap
          if (rgEnd<PAend + PAgap)  rgEnd=PAend + PAgap
        } else {
          rgStart=PAstart - PAgap
          rgEnd=PAend + PAgap
        }

        if (VT$cells.annoBar.pos=='left') {
          x1=rgStart
        } else if (VT$cells.annoBar.pos=='right') {
          x1=rgEnd-PAwidth
        }
      }

      cellDf=data.frame(cellid=rownames(PACdf))
      cellDf$y=1:nrow(cellDf)
      cellDf$x1=x1
      cellDf$x2=x1+PAwidth
      grp=data.frame(group=PACds@colData[, group], cellid=rownames(PACds@colData))
      cellDf=merge(cellDf, grp)

      tck <- ggplot() +
        geom_segment(data=rasterDf, aes(x=x1, xend=x2, y=y, yend=y, color=PA), linewidth=1) +
        scale_colour_gradient2(low=VT$cells.scale.low, high=VT$cells.scale.high, mid = VT$cells.scale.mid,
                               limits = c(min_value, max_value), midpoint = mid, oob = scales::squish)  +
        labs(color = legendLab) + viz_noY_theme +
        ggnewscale::new_scale_colour() +
        geom_segment(data=cellDf, aes(x=x1, xend=x2, y=y, yend=y, color=group), linewidth=1) +
        scale_colour_manual(values = groupColors)
    } else { # without legend of cells
      tck <- ggplot() +
        geom_segment(data=rasterDf, aes(x=x1, xend=x2, y=y, yend=y, color=PA), linewidth=1) +
        scale_colour_gradient2(low=VT$cells.scale.low, high=VT$cells.scale.high, mid = VT$cells.scale.mid,
                               limits = c(min_value, max_value), midpoint = mid, oob = scales::squish)  +
        labs(color = legendLab) + viz_noY_theme
    }

    tcks[[1]]=tck

    if (0) { ## not used ## geom_raster or geom_tile very slow
      y=1:nrow(PACdf)
      rasterDf=PACdf

      for (i in 1:length(PACdsGR)) { # PA1..PAn
        start=start(PACdsGR)[i]
        end=end(PACdsGR)[i]
        for (j in start:end) {
          d1=.asDf(PACdf[, i, drop=F])
          colnames(d1)='PA'
          d1$y=y
          d1$x=rep(j, nrow(PACdf))
          if (i==1 & j==start) {
            rasterDf=d1
          } else {
            rasterDf=rbind(rasterDf, d1)
          }
        }
      }

      dim(rasterDf)
      head(rasterDf)
      #unique(rasterDf$x)

      tck=ggplot(data = rasterDf) +
        geom_raster(aes(x = x, y = y, fill = PA)) +
        scale_fill_viridis_c() +
        # scale_fill_gradient2(
        #   low = "white", mid = "darkorange", high = "black",
        #   limits = c(min_value, max_value), midpoint = mid, oob = scales::squish
        # ) +
        theme_void() +
        theme(legend.position = "none")
      # coord_equal() # one degree in latitude and longitude are the same length on the map.
      invisible(gc)
    } ## if 0

  } else {
    cat( sprintf('No PAs of the PACds in the plot-region [ %s ], the cells-track is not shown!\n', genomicRegion))
  }
  if (!is.null(title) & length(tcks)>0) names(tcks)=title[1]
  return(tcks)
}


# get new chr names of the givenChr in chrMaps
# getMappedChr('chr1', c('chr1','chr2','xxxx'), data.frame(c1=1:3, c2=paste0('chr',1:3))) #chr1
# getMappedChr('1', c('chr1','chr2','xxxx'), data.frame(c1=1:3, c2=paste0('chr',1:3))) #chr1
# getMappedChr('5', c('chr1','chr2','xxxx'), data.frame(c1=1:3, c2=paste0('chr',1:3))) #5
# getMappedChr('5', c('chr1','chr2','xxxx'), data.frame(c1=1:3, c2=paste0('chr',1:3)), must=TRUE) #error
# getMappedChr('5', c('chr1','chr2','xxxx'), data.frame(c1=1:3, c2=paste0('chr',1:3)), must=FALSE) #NULL
getMappedChr<-function(givenChr, chrs, chrMaps, must=FALSE) {
  if (length(givenChr)>1) stop("givenChr should be of length 1!")
  if (givenChr %in% chrs) return(givenChr)
  n=c()
  rid=c()
  for (i in 1:ncol(chrMaps)) {
    n=c(n, length(intersect(chrMaps[,i], chrs)))
    if (length(rid)==0) rid=which(chrMaps[i]==givenChr)
  }
  if (length(rid)==0) {
    if (must) stop('givenChr ',givenChr,' not found in chrs/chrMaps!')
    return(c())
  }
  i=which(n==max(n)) # the colid with max overlapping is the chrs's column
  return(chrMaps[rid[1], i[1]])
}


#' Get all tracks in a genomic region
#'
#' vizTracksOfRegion gets all tracks in a genomic region, including gene model track, pA track(s) and BAM track(s).
#'
#' @param genomicRegion A string with four fields describing a genomic region, like 1:-:1000:100000.
#' @param annoSource An annoHub object. If it is empty, then plot the chromosome region instead of gene model.
#' @param bams A dataframe describing the BAM file list. See the output of readBAMFileNames().
#' @param PACds.list A PACdataset or a list of PACdatasets.
#' @param PA.show A vector describing the information of pA to extract, e.g., PA.show=c('pos','tag').
#'                  PA.show=pos means extracting the coordinates of pAs; other values (e.g., tag, tot_tagnum) should be the column in PACds@anno or PACds@counts denoting the expression level of pAs.
#' @param cells TRUE to add track of individual cells. Parameters starting with "cells" are applicable only when cells=TRUE.
#' @param cells.group The column name recording cell categories in PACds@colData.
#' @param cells.width Similar to PA.width, but for the width of the cells bar. The final bar width=2*cell.width+1.
#' @param cells.annoCoord The position to put the annotation bar of cell groups, only used when group is not NULL.
#' @param cells.method To set the method for ordering cells, diffusion (default, using diffusion map to order cells -- see Millefy Package) or sum (using the sum of all pAs)
#' @param cells.sort To sort cells within group (group) or without group (all), or not sort (none, default).
#' @param PA.columns A string denoting the pA coordinates (e.g., coord) or ranges (e.g., UPA_start:UPA_end).
#' @param PA.width If PA.columns is a position (e.g., coord), then the pA range can be expanded by PA.width to be visualized more clearly in the track plot.
#'                 For example, if PA.width=10, then the pA position would be converted to a range of 2*PA.width+1 with the pA in the center.
#' @param vizTheme a vizTHEME-like list to specify the theme of the track.
#' @return A list of two elements: tracks for track list of gene model track, pA track(s) and BAM track(s); and h for track heights.
#'         The number of tracks depends on vizTheme (for BAM tracks), and PACds.list and PA.show (for PA tracks).
#' @examples
#' \dontrun{
#' tks=vizTracksOfRegion(genomicRegion='1:+:1000:10000',
#'                             annoSource=new("annoHub"),
#'                             bams=bams, PACds.list=list(PACds, p2=PACds),
#'                             PA.show=list("pos","value"),
#'                             PA.columns="coord", PA.width=10,
#'                             vizTheme=NULL, toPlot=TRUE)
#' tracks(tks)
#'
#' vizTheme=list(bam.covStyle='curve', bam.showMerge=TRUE, bam.covMerge='avg')
#' tks=vizTracksOfRegion(genomicRegion='1:+:1000:10000',
#'                   annoSource=new("annoHub"),
#'                   bams=bams, PACds.list=list(PACds, p2=PACds),
#'                   PA.show=list("pos","value"),
#'                   PA.columns="coord", PA.width=10,
#'                   vizTheme=vizTheme, toPlot=TRUE)
#' }
#' @name vizTracksOfRegion
#' @family vizTracks functions
#' @export
vizTracksOfRegion<-function(genomicRegion,
                            annoSource=new("annoHub"),
                            bams=NULL,
                            PACds.list=NULL, PA.show=c("pos"),
                            cells=FALSE, cells.group=NULL,
                            cells.width=100, cells.annoCoord=NULL,
                            cells.method=c('sum','diffusion'), cells.sort=c('none', 'all','group'),
                            PA.columns="coord", PA.width=10,
                            vizTheme=NULL) {

  heights=c()
  VT=setVizTheme(vizTheme, check=TRUE)

  regionLst <- .covStrRegion(genomicRegion, rt='list')
  givenChr=regionLst$chr

  # each region for each data
  bamRg=regionLst; annoRg=regionLst; paRg=regionLst

  chrMaps=data.frame()
  if (!is.null(annoSource)) chrMaps=annoSource@chrMappings

  # if givenChr not in getChrs, update it!
  if (!is.null(bams)) {
    bamChrs=getChrs(bams)
    if (!(givenChr %in% bamChrs)) {
      if (nrow(chrMaps)==0)
        stop ("chrname ", givenChr, " not in bams, please make them consistent first or provide annoSource@chrMappings!\n")

      newChr=getMappedChr(givenChr, bamChrs, chrMaps, must=TRUE)
      if (newChr!=givenChr) cat( sprintf("New chr mapping of bams: %s --> %s \n",
                                         givenChr, newChr) )
      if (length(newChr)==1) bamRg$chr=newChr
    }
  }

  if (!is.null(PACds.list)) {
    paChrs=getChrs(PACds.list[[1]])

    if (!(givenChr %in% paChrs)) {
      if (nrow(chrMaps)==0)
        stop ("chrname [", givenChr, "] not in PACds.list, please make them consistent first or provide annoSource@chrMappings!\n")

      newChr=getMappedChr(givenChr, paChrs, chrMaps, must=TRUE)
      if (newChr!=givenChr) cat("New chr mapping of PACds:",givenChr,'-->',newChr,'\n' )
      if (length(newChr)==1) paRg$chr=newChr
    }
  }


  if (!is.empty(annoSource))  {
    annoChrs=getChrs(annoSource)
    if (!(givenChr %in% annoChrs)) {
      if (nrow(chrMaps)==0)
        stop ("chrname [", givenChr, "] not in annoSource, please make them consistent first or provide annoSource@chrMappings!\n")

      newChr=getMappedChr(givenChr, annoChrs, chrMaps, must=TRUE)
      if (newChr!=givenChr)
        cat( sprintf("New chr mapping of annoSource [ %s ]: %s --> %s\n",
                    annoSource@defaultAnno, givenChr, newChr) )
      if (length(newChr)==1) annoRg$chr=newChr
    }
  }

  ## chr consistent or have updated
  bamRg=.covGRregion(bamRg, rt='str')
  annoRg=.covGRregion(annoRg, rt='str')
  paRg=.covGRregion(paRg, rt='str')

  cat('Get gene model track from annoSource[', annoSource@defaultAnno,']...\n')
  geneModelTrack=getTrackGeneModel(genomicRegion=annoRg, gene=NULL, annoSource=annoSource)
  names(geneModelTrack)='Gene\nModel'

  tks=geneModelTrack

  heights=rep(1, length(tks))

  ## pA track -- one track one PACds.list[i] in THIS region, with pA positions as box
  if (!is.null(PACds.list)) {

    if (inherits(PACds.list, 'PACdataset')) {
      PACds.list=list(PACds.list)
      names(PACds.list)='PACds'
    }

    if (!inherits(PACds.list, 'list')) stop("The input PACds.list should be either a PACdataset or a list!")
    for (i in 1:length(PACds.list)) {
      if (names(PACds.list)[i]=='') names(PACds.list)[i]=paste0('PACds',i)
      PACds=PACds.list[[i]]

      cat('Get PACds track...\n')
      tck=getTrackPACds(PACds, genomicRegion=paRg,
                        gene=NULL,
                        PAs=NULL,
                        PA.show=PA.show,
                        PA.columns=PA.columns, PA.width=PA.width, vizTheme=vizTheme )


      if (length(tck)==1) {
        tks[[names(PACds.list)[i]]]=tck[[1]]
        if (length(PA.show)==1 & PA.show=='pos')  heights=c(heights, 0.5)  else   heights=c(heights, 1)
      } else if(length(tck)>1) {
        names(tck)=paste0(names(PACds.list)[i], '.',PA.show)
        tks=c(tks, tck)
        for (i in PA.show) {
          if (i=='pos') heights=c(heights, 0.5) else  heights=c(heights, 1)
        }
      }
    }
  }


  if (cells) {
    cat('Get cells track...\n')
    cellstks=getTrackCells(PACds=PACds.list[[1]],
                           genomicRegion=paRg,
                           gene=NULL,
                           PAs=NULL,
                           group=cells.group,
                           sortMethod=cells.method, sortCells=cells.sort,
                           PA.columns=PA.columns, PA.width=cells.width,
                           annoCoord=cells.annoCoord, vizTheme=vizTheme)
    tks=c(tks, cellstks)
    heights=c(heights, rep(1, length(cellstks)))
  }

  ## BAM tracks
  if (!is.null(bams)) {
    # bams=bams[bams$strand==regionLst$strand, , drop=F]
    if (nrow(bams)>0) {
      cat('Get BAM tracks...\n')
      bamtks=getTrackBams(bams, genomicRegion=bamRg, vizTheme=vizTheme)
      tks=c(tks,bamtks)
      heights=c(heights, rep(1, length(bamtks)))
    }

  }

  invisible(gc())
  return(list(tracks=tks, h=heights))
}


#' Get all tracks for a genomic region, a gene, or pAs
#'
#' vizTracks gets all tracks for a genomic region, a gene, or pAs, including gene model track, pA track(s), cells track, and BAM track(s).
#' \itemize{
#' \item{"gene model track"}: plot gene models given a specific region or a gene symbol/ID, according to the annotation(s) in the annoHub object.
#' \item{"pA track"}: plot the positions, expression levels, APA ratios for a PACdataset or multiple PACdataset objects.
#' \item{"cells track"}: plot counts or ratios of individual cells using gradient colors.
#' \item{"BAM track"}: plot BAM coverage using lines or areas for individual cell groups or merged cell groups.
#' }
#'
#' @param genomicRegion A string with four fields describing a genomic region, like 1:-:1000:100000.
#' @param gene A gene name, gene symbol, or gene id to filter PACds and gene model in the given gene.
#' @param PAs A vector of pA ids corresponding to rownames of PACds@counts.
#' @param bams A dataframe describing the BAM file list. See the output of readBAMFileNames().
#' @param PACds.list A PACdataset or a list of PACdatasets.
#' @param PA.show A vector describing the information of pA to extract, e.g., PA.show=c('pos','tag').
#'                  PA.show=pos means extracting the coordinates of pAs; other values (e.g., tag, tot_tagnum) should be the column in PACds@anno or PACds@counts denoting the expression level of pAs.
#' @param cells TRUE to add track of individual cells. Parameters starting with "cells" are applicable only when cells=TRUE.
#' @param cells.group The column name recording cell categories in PACds@colData.
#' @param cells.width Similar to PA.width, but for the width of the cells bar. The final bar width=2*cell.width+1.
#' @param cells.annoCoord The position to put the annotation bar of cell groups, only used when group is not NULL.
#' @param cells.method To set the method for ordering cells, diffusion (default, using diffusion map to order cells -- see Millefy Package) or sum (using the sum of all pAs)
#' @param cells.sort To sort cells within group (group) or without group (all), or not sort (none, default).
#' @param annoSource An annoHub object.
#' @param PA.columns A string denoting the pA coordinates (e.g., coord) or ranges (e.g., UPA_start:UPA_end).
#' @param PA.width If PA.columns is a position (e.g., coord), then the pA range can be expanded by PA.width to be visualized more clearly in the track plot.
#'                 For example, if PA.width=10, then the pA position would be converted to a range of 2*PA.width+1 with the pA in the center.
#' @param logPA TRUE to log2(PACds@counts+1) for count-type PACds, which will affect the pA and cells tracks.
#' @param space5 e.g, 1000 means to expand the 5' end of the gene model range by 1000 bp.
#' @param space3 e.g, 1000 means to expand the 3' end of the gene model range by 1000 bp.
#' @param vizTheme a vizTHEME-like list to specify the theme of the track.
#' @param res A character of a PDF file name or 'plot' to plot in the current device or 'list/track' to return a list of tracks.
#' @return A plot or pdf (res=plot/pdffile) or a track lists (res=track/list). The height of the track(s) of pA position is half of other tracks.
#'         The number of tracks depends on vizTheme (for BAM tracks), and PACds.list and PA.show (for PA tracks).
#' @examples
#' # This is the wrapper function for visualizing the track plots,
#' # please see the vignette of vizAPA for full examples.
#' @name vizTracks
#' @family vizTracks functions
#' @export
vizTracks<-function(genomicRegion=NULL,
                    gene=NULL,
                    PAs=NULL,
                    bams=NULL,
                    PACds.list=NULL, PA.show=c("pos"),
                    cells=FALSE, cells.group=NULL, cells.width=100, cells.annoCoord=NULL,
                    cells.method=c('sum', 'diffusion'), cells.sort=c('none', 'all','group'),
                    annoSource=new("annoHub"),
                    PA.columns="coord", PA.width=10, logPA=FALSE,
                    space5=1000, space3=1000,
                    vizTheme=NULL, res='plot') {

  if (is.null(res)) res='plot'
  res=tolower(res); toPDF=FALSE
  if (length(grep('\\.pdf$', res))>0) {
    toPDF=TRUE
  } else if (!(res %in% c('plot','list', 'track'))) {
    stop('res should be plot or list/track or a .pdf file name!')
  }

  if (!is.null(genomicRegion) & !is.null(gene)) stop("Either plot a genomicRegion or a gene, cannot provide both genomicRegion and gene!")

  if (is.null(PACds.list) & !is.null(PAs)) stop("Should provide PACds.list when PAs is not null!")

  if (is.null(PACds.list) & cells) stop("Should provide PACds.list when cells is TRUE!")

  if (inherits(PACds.list, 'PACdataset')) {
    PACds.list=list(PACds.list)
    names(PACds.list)='PACds'
  }

  if(!inherits(PACds.list, 'list')) stop("The input PACds.list should be either a PACdataset or a list of PACdatasets!")

  for (i in 1:length(PACds.list)) {
    if (names(PACds.list)[i]=='') names(PACds.list)[i]=paste0('PACds',i)
    #only count type can be log
    if (logPA) PACds.list[[i]]=logPACds(PACds.list[[i]])
  }

  if (cells) {
    if (length(PACds.list)>1) cat("Multiple PACdatasets in PACds.list, use the first one for getTrackCells.\n")
    cells.sort = validate.arg(cells.sort, c('none', 'all','group'))
    cells.method = validate.arg(cells.method, c('sum', 'diffusion'))

    if (is.null(cells.group)) {
      if (cells.sort=='group') stop("cells.group=NULL, cells.sort should be none/all!")
    }

    if (!is.null(cells.group)) {
      if (!(cells.group %in% colnames(PACds.list[[1]]@colData))) stop('cells.group not in PACds.list[[1]]@colData!')
    }
  }

  ## region is provided
  gr=.covStrRegion(genomicRegion, check = TRUE, rt='list')

  .getGRfromPACds<-function(PACds.list, gene) {
    gr=list(chr=NA, strand=NA, start=NA, end=NA)
    for (i in 1:length(PACds.list)) {
      PACds=PACds.list[[i]]
      if ( sum(c('chr','strand','gene','gene_start','gene_end') %in% colnames(PACds@anno))==5 ) {
        subg=PACds@anno[PACds@anno$gene==gene, c('chr','strand','gene_start','gene_end'), drop=F]
        subg=subg[rowSums(is.na(subg))==0, ]
        if (nrow(subg)>0) {
          gr=list(chr=as.character(subg$chr[1]), strand=as.character(subg$strand[1]), start=subg$gene_start[1], end=subg$gene_end[1])
          cat( sprintf("Found gene region for gene [%s] in PACds: %s|%s|%s%s\n",
                      gene, gr$chr, gr$strand, gr$start, gr$end) )
          break
        }
      }
    }
    return(gr)
  }

  # gene is provided, get gene_start/end from annoSource or PACds.list
  if (!is.null(gene)) {

    if (!is.empty(annoSource)) {
      gr1=getGenesRange(genes=gene, annoSource)
      gr=.covGRregion(gr1, rt='list')
    }

    if (is.na(gr$start) & !is.null(PACds.list)) {
      #earch the gene_start/gene_end region in PACds@anno, if provided
      cat( sprintf("Cannot find any range for gene [%s] from annoSource, try to get gene-range from PACds.list.\n", gene) )
      gr=.getGRfromPACds(PACds.list, gene)
    }

    if (is.na(gr$start)) stop("Cannot find the region info for gene=", gene, " (no gene information in annoSource or PACds.list (gene_start/end))!")

    ## If gene is provided and it is in the pacds column, then the data for that gene will be filtered out first to prevent multiple gene results from being generated for a single region
    for (i in 1:length(PACds.list)) {
      if ('gene' %in% colnames(PACds.list[[i]]@anno)) {
        p1=movAPA::subsetPACds(PACds.list[[i]], gene=gene)
        PACds.list[[i]]=p1
        if(length(p1)==0) {
          cat( sprintf("gene column is in PACds.list[[%d]], but there is no PA in gene [%s]. You may use GenomicRegion to check.\n",
                      i, gene) )
        }
      }
    }
  }

  if (is.na(gr$start)) stop("Cannot find the region info for genomicRegion (", genomicRegion,") or gene (", gene, ") (no gene information in PACds@anno and annoSource=NULL)!")


  if(gr$strand=="-"){
    gr$start<- gr$start-space3
    gr$end<-gr$end+space5
  }else{
    gr$start<-gr$start-space5
    gr$end<-gr$end+space3
  }

  if(gr$end- gr$start>50000)
    cat( sprintf("The region may be too large to plot [%d nt], you can set genomicRegion to plot a smaller region\n", gr$end-gr$start ))

  # PAs (PA names) is provided, then filter PAs of EACH PACds to show filtered PAs only
  if (!is.null(PAs)) {
    for (i in 1:length(PACds.list)) {
      PACds=movAPA::subsetPACds(PACds.list[[i]], PAs=PAs)
      PACds.list[[i]]=PACds
      if (length(PACds)==0) {
        cat("Warning: cannot find any pA in PACds for the provided PACds ",names(PACds.list)[i],", no pA would be shown in the track plot!")
      } else {
        cat( sprintf("PAs is provided, so only show %d pAs on the pA track of %s\n", length(PACds), names(PACds.list)[i]) )
      }
    }
  }

  # vizTracksOfRegion<-function(genomicRegion,
  #                             annoSource=new("annoHub"),
  #                             bams=NULL,
  #                             PACds.list=NULL, PA.show=c("pos"),
  #                             cells=FALSE, cells.group=NULL, cells.annoCoord=NULL,
  #                             cells.method=c('diffusion','sum'), cells.sort=c('none', 'all','group'),
  #                             PA.columns="coord", PA.width=10,
  #                             vizTheme=NULL, toPlot=FALSE)

  cat("Plot tracks for region:", .covGRregion(gr), '\n')
  lst=vizTracksOfRegion(genomicRegion=paste(unlist(gr), collapse=':'),
                        annoSource=annoSource,
                        bams=bams,
                        PACds.list=PACds.list, PA.show=PA.show,
                        cells=cells, cells.group=cells.group,
                        cells.width=cells.width, cells.annoCoord=cells.annoCoord,
                        cells.method=cells.method, cells.sort=cells.sort,
                        PA.columns=PA.columns, PA.width=PA.width,
                        vizTheme=vizTheme)
  tks=lst[[1]]
  h=lst[[2]]
  if (toPDF) {
    grDevices::pdf(file=res)
    #x=capture_messages(tracks(tks))
    ggbio::tracks(tks, heights=h)
    grDevices::dev.off()
  } else {
    if (res=='plot') {
      ggbio::tracks(tks, heights=h)
      # x=capture_messages(tracks(tks))
    } else {
      return(tks)
    }
  }
}


# -------------- *** vizStats **** ---------------
## Add supp info of a PACdataset, dataType=count/ratio; row=PA/gene
## suppPACds(scPACds)@supp$row
suppPACds<-function(PACds, refresh=TRUE) {
  if (refresh) {
    PACds@supp$row=NULL
    PACds@supp$dataType=NULL
  }

  row=NULL
  if (is.null(PACds@supp$row)) {
    if ('ftr' %in% colnames(PACds@anno)) {
      ftrs=unique(PACds@anno$ftr)
      if (sum(c('3UTR','CDS','intron','exon','5UTR') %in% ftrs)>0) row='PA'
    }

    if ( AinB(colnames(PACds@anno), c('chr','strand','coord'), all=TRUE) & !is.null(row) ) {
      row='PA'
    }

    if ( !('gene' %in% colnames(PACds@anno)) & is.null(row)) {
      row='PA'
    }

    if (is.null(row)) row='gene'
  }

  if (is.null(PACds@supp$dataType)) {
    if (max(PACds@counts, na.rm=TRUE)>1) {
      PACds@supp$dataType='count'
    } else {
      PACds@supp$dataType='ratio'
    }
  }

  PACds@supp$row=row
  return(PACds)
}


statTHEME=list(
  ##vizStats: box, violin, point
  group.cols=c(brewer.pal(8, "Set2"), brewer.pal(8, "Set1")),
  outlier.colour="grey",
  outlier.shape=8,
  outlier.size=1,
  alpha=0.8,

  ## bubble/markers-dot/heatmap
  scale.low.col='#8d9fbb',
  scale.high.col='#aa3e53',

  ## umap
  umap.point.size=1,
  umap.legend.size=6,
  umap.legend.key.size=0.4,
  umap.legend.point.size=1.5,

  ## markers
  xgroup=TRUE, #for violin/dot plots

  hm.disp.min=-2.5, #for heatmap
  hm.disp.max=NULL,
  hm.label = TRUE,
  hm.size = 5.5,
  hm.hjust = 0,
  hm.angle = 45,
  hm.raster = TRUE,
  hm.draw.lines = TRUE,
  hm.lines.width = NULL,
  hm.group.bar.height = 0.02,

  dot.scale=FALSE, # for dot plot

  ## marker umaps
  umaps.ncol = 2
)

#' Set the plot theme for vizStats
#'
#' setStatTheme sets the drawing theme for vizStats, by setting default values using statTHEME and checking the validity.
#'
#' @param statTheme A list similar to statTHEME, containing the following parameters.
#' \itemize{
#' \item{group.cols}: parameter for vizStats(box/violin/point), colors for cell groups, default is `c(brewer.pal(8, "Set2"), brewer.pal(8, "Set1"))`.
#' \item{outlier.colour}: parameter for vizStats(box/violin/point), color for outliers, defaut is "grey".
#' \item{outlier.shape}: parameter for vizStats(box/violin/point), shape for outliers, defaut is 8.
#' \item{outlier.size}: parameter for vizStats(box/violin/point), size for outliers, default is 1.
#' \item{alpha}: parameter for vizStats(box/violin/point), the transparent alpha, default is 0.8.
#'
#' \item{scale.low.col}: parameter for bubble/markers-dot/heatmap, low point of the gradients, default is '#8d9fbb'.
#' \item{scale.high.col}: parameter for bubble/markers-dot/heatmap, high point of the gradients, default is '#aa3e53',
#'
#'
#' \item{umap.point.size}: parameter for the UMAP plot, the point size, default is 1.
#' \item{umap.legend.size}: parameter for the UMAP plot, the legend text size, default is 6.
#' \item{umap.legend.key.size}: parameter for the UMAP plot, the legend key size, default is 0.4.
#' \item{umap.legend.point.size}: parameter for the UMAP plot, the legend point size, default is 1.5.
#'
#' \item{xgroup}: parameter for the marker plots (iolin/dot plots), whether show cell groups on X-axis, default is TRUE.
#'
#' \item{hm.disp.min}: parameter for the heatmap, default is -2.5, details see Seurat::DoHeatmap.
#' \item{hm.disp.max}: Default is NULL, details see Seurat::DoHeatmap.
#' \item{hm.label }:  Default is TRUE, details see Seurat::DoHeatmap.
#' \item{hm.size }:  Default is 5.5, details see Seurat::DoHeatmap.
#' \item{hm.hjust }:  Default is 0, details see Seurat::DoHeatmap.
#' \item{hm.angle }:  Default is 45, details see Seurat::DoHeatmap.
#' \item{hm.raster }:  Default is TRUE, details see Seurat::DoHeatmap.
#' \item{hm.draw.lines }: Default is TRUE, details see Seurat::DoHeatmap.
#' \item{hm.lines.width }: Default is NULL, details see Seurat::DoHeatmap.
#' \item{hm.group.bar.height }: Default is 0.02, details see Seurat::DoHeatmap.
#'
#' \item{dot.scale}: parameter for the dot plot, default is FALSE.
#'
#' \item{umaps.ncol}: parameter for the markers' multiple UMAP plots, which set the number of columns in the plot, default is 2.
#' }
#' @param check Whether to check the validity of values (default is TRUE).
#' @return A list.
#' @examples
#' setStatTheme(NULL)
#' setStatTheme(list(group.cols=brewer.pal(8, "Set1")), check=TRUE)
#' @name setStatTheme
#' @family vizStats functions
#' @export
setStatTheme <- function(statTheme, check=TRUE) {
  ## set color themes
  if (!is.null(statTheme)) {
    if (!is.list(statTheme)) stop("statTheme should be a list storing cols and shapes for the stat plot, see statTHEME!")

    for (i in names(statTHEME)) { # for pars not set in vizTheme, use the default one.
      if (!(i %in% names(statTheme))) {
        statTheme[[i]]=statTHEME[[i]]
      }
    }
  } else {
    statTheme=statTHEME # default theme
  }

  for (i in names(statTheme)) {
    if (is.character(statTheme[[i]])) {
      statTheme[[i]]=tolower(statTheme[[i]])
    }
  }

  return(statTheme)
}

#' Draw statistic plots
#'
#' vizStats draws different types of plots, including boxplot, violin plot, dot plot, and bubble plot, to show coordinates and expression (in count or ratio) of given pAs or pAs in a gene across different conditions (e.g., cell types).
#'
#' @param PACds A dataset of the PACdataset class.
#' @param group The column recording cell categories in PACds@colData.
#' @param selGroups A vector to specify the order and categories to plot, otherwise plot all or the first 10 (if N>10) categories.
#' @param gene A gene name, gene symbol, or gene id to filter PACds and gene model in the given gene.
#' @param PAs A vector of pA ids corresponding to rownames of PACds@counts.
#' @param figType box for boxplot, violin for violin plot, dot for violin plot with dots, bubble for bubble plot.
#' @param log Only applicable when PACds is of count type rather then ratio type.
#' @param statTheme A statTHEME-like list to specify the theme of the plot.
#' @return A ggplot2 plot. The x-axis is normally the cell groups (e.g., cell types), and cell groups can be selected and sorted by selGroups.
#'         The y-axis is the value or mean of (all genes or pAs if both PA and gene are not provided; one gene -- if gene is provided; individual PAs -- if PAs is provided) in all cells of each cell type.
#'         If PACds@supp$row=PA, there can be multiple pAs after subsetting PACds by gene or PAs.
#'         In this case, there can be >1 resulting rows, which means that a cell type's boxplot will have multiple groups denoting multiple PAs.
#'         In other cases, the plot only shows one gene or one PA.
#' @examples
#' \dontrun{
#' #plot a violin plot to show the expression levels of all pAs in a given gene across cell types.
#' gene=252868
#' vizStats(PACds, group='celltype', gene=gene, PAs=NULL, figType="violin")
#' #Plot other types of plots.
#' # boxplot
#' vizStats(PACds, group='celltype', gene=gene, PAs=NULL, figType="box")
#' # violin plot with dots
#' vizStats(PACds, group='celltype', gene=gene, PAs=NULL, figType="dot")
#' # bubble plot
#' vizStats(PACds, group='celltype', gene=gene, PAs=NULL, figType="bubble")

#' # plot the given pAs, by specifying the rowid of PAs in the PACds.
#' # First we get the PA ids of this gene
#' PAids=rownames(subsetPACds(PACds, genes=gene)@anno)
#' # Plot a violin plot with dots
#' vizStats(PACds, group='celltype', PAs=PAids, figType="dot")
#'
#' # We can modify the display of the figure by changing colors or
#' # other parameters, providing the `statTheme` parameter.
#' # To use another color palette
#' vizStats(PACds, group='celltype', gene=gene, figType="violin",
#'         statTheme=list(group.cols=c(brewer.pal(8, "Set1"))))
#'
#' # We can change the order of groups (e.g., cell types)
#' # by specifying `selGroups`.
#' # change the order to RS>SC>ES
#' vizStats(PACds, group='celltype', selGroups=c('RS','SC','ES'))
#'
#' # If the expression level in PACds is count,
#' # we can also show the value in log scale if `log=TRUE`.
#' # vioin plot with dots
#' vizStats(PACds, group='celltype', figType="dot", log=TRUE)
#' # bubble plot
#' vizStats(PACds, group='celltype', figType="bubble", log=TRUE)
#' }
#' @name vizStats
#' @family vizStats functions
#' @export
vizStats<-function(PACds, group, selGroups=NULL, gene=NULL, PAs=NULL,
                   figType=c('violin','box','dot','bubble'), log=FALSE, statTheme=NULL) {

  figType=validate.arg(figType, c('violin','box','dot','bubble'))

  ST=setStatTheme(statTheme)

  if (!is.null(gene) & !is.null(PAs)) stop("Can only specify gene or PAs!")
  # determine data type and row type
  PACds=suppPACds(PACds, refresh = TRUE)
  # only count type can be log
  if (log & PACds@supp$dataType!='count') stop("PACds@counts is not count but ratio data (<1), cannot apply log=TRUE!")

  cols=selGroups
  if (is.null(cols)) {
    cols=unique(PACds@colData[, group])
  }
  # at most 10 samples can be plot
  if(length(cols)>10){
    message("Warning: too many groups (>10) to plot, only show the first 10, please use subsetPACds() to filter less groups")
    cols=cols[1:10]
  }

  # filter gene or PA, if not filter, then plot mean of all gene/PA
  if (is.null(gene) & is.null(PAs)) { #mean of all gene/PA
    PACds1=movAPA::subsetPACds(PACds, group=group, conds=cols)
    PACds1@counts[1, ]=colMeans(PACds1@counts, na.rm = TRUE)
    PACds1@counts=PACds1@counts[1, , drop=F]
    rownames(PACds1@counts)='MEAN'
  } else if (!is.null(gene)) {
    PACds1=movAPA::subsetPACds(PACds, group=group, conds=cols, genes=gene)
  } else if (!is.null(PAs)) {
    if (PACds@supp$row!='PA') stop("PACds is not a PA list, cannot specify PAs!")
    PACds1=movAPA::subsetPACds(PACds, group=group, conds=cols, PAs=PAs)
  }

  if (length(PACds1)==0) {
    cat("Not any data from PACds for plot, return!\n")
    return(invisible(NULL))
  }

  if (log) PACds1=logPACds(PACds1)

  xlab=group

  if (PACds@supp$dataType=='count') {
    ylab='Count'
    if (log) ylab='Log2(count)'
  } else {
    ylab='Ratio'
  }

  d= data.frame(rowid=rownames(PACds1@colData), group=PACds1@colData[, group])
  d2=data.frame(rowid=colnames(PACds1@counts), .asDf(t(PACds1@counts)))
  d=merge(d, d2, by.x='rowid', by.y='rowid') # rowid (cellid), group (celltype), PA1..PAn (or gene)

  d=d %>% tidyr::pivot_longer(cols=rownames(PACds1@counts), names_to = 'which', values_to = "Expr")


  fill='which' # if >=2 PA, the the color is for PA, otherwise group/cell type are different colors
  if (nrow(PACds1@counts)==1) {  #single gene/PA
    ylab=paste0(ylab, ' of ', rownames(PACds1@counts))
    fill='group'
  } else if (nrow(PACds1@counts)>16) {
    stop("vizStats: too many pAs (>16) to plot, please set PAs parameter to reduce pA number!")
  } else if (nrow(PACds1@counts)>=5) {
    warning("vizStats: too many pAs (>5) to plot, the plot may be very messy, please set PAs parameter to reduce pA number!")
  }

  ## sort X-axis by cols
  d$group=factor(d$group, levels = cols)

  ## for bubble, then summarize the number of average sum> 0 under each group
  if(figType=='bubble') {
    by_group <- dplyr::group_by(d, group, which)
    d2=dplyr::summarise(by_group, percent = sum(Expr>0),
                 avg=mean(Expr, na.rm=TRUE),
                 .groups='drop')
    p=ggplot(d2, aes(x = group, y = which, size = percent , color=avg))+
      geom_point(alpha = ST$alpha) + scale_color_gradient(low=ST$scale.low.col, high=ST$scale.high.col)
    p=p + theme_classic() + xlab(xlab)
    return(p)
  }

  if(figType=="box")   {
    p<-ggplot(d, aes(x=group, y=Expr)) +
      geom_boxplot(aes(fill=.data[[fill]]), alpha=ST$alpha, outlier.colour=ST$outlier.colour,
                   outlier.shape=ST$outlier.shape,
                   outlier.size=ST$outlier.size
      ) +  ## mark outliers by outlier
      # stat_boxplot(geom = "errorbar",
      #              linewidth=0.5,
      #              width=0.2)+
      scale_fill_manual(values=ST$group.cols)
  }

  if(figType=="violin")    {
    p<-ggplot(d, aes(x=group, y=Expr)) +
      geom_violin(aes(fill=.data[[fill]]), alpha=ST$alpha) +
      #stat_summary(fun.data="mean_sdl", fun.args = list(mult=1),
      #             geom="pointrange", color = "red")+  #add mean and sd
      scale_fill_manual(values=ST$group.cols)
  }

  if(figType=="dot")     {
    p<-ggplot(d, aes(x=group, y=Expr)) +#color is for line, fill is for filled color
      geom_jitter(aes(color=.data[[fill]]), alpha=0.3,
                  position=position_jitterdodge(jitter.width=0.35,
                                                jitter.height=0,
                                                dodge.width=0.8))+
      #   geom_boxplot(aes(fill=.data[[fill]]), alpha=0.3, width=0.45,
      #                position=position_dodge(width=0.8),
      #                linewidth=0.6, outlier.colour=NA)+
      geom_violin(aes(fill=.data[[fill]]), alpha=0.3, width=0.9,
                  position=position_dodge(width=0.8),
                  linewidth=0.6)+
      scale_colour_manual(values=ST$group.cols)+
      scale_fill_manual(values=ST$group.cols)
  }
  p=p + theme_classic() + ylab(ylab) + xlab(xlab)
  return(p)
}


# -------------- *** vizUMAP **** ---------------
#' Reduce dimensions by running the Seurat's pipeline on a PACdataset
#'
#' reduceDim reduces dimensions by running the Seurat's pipeline on a PACdataset.
#'
#' @param PACds A dataset of the PACdataset class.
#' @param nfeature Number of features to select as top variable features, used in the 'vst' method.
#' @param dims Which dimensions from PCA to use as input features .
#' @param dimLabel The label added or overwritten in the colData of PACds.
#' @param norm If norm=TRUE and the datatype of PACds is count, then LogNormalize will be applied.
#' @return A PACdataset with extra columns denoting the 2D-embeddings of the UMAP plot.
#' @examples
#' data(scPACds)
#' ## get embeddings using the pA count matrix with normalization
#' PACds=reduceDim(scPACds, nfeature=2000, dims=1:10, dimLabel='umap_norm', norm=TRUE)
#' ## without normalization
#' PACds=reduceDim(scPACds, nfeature=2000, dims=1:10, dimLabel='umap_raw', norm=FALSE)
#' @name reduceDim
#' @family vizUMAP functions
#' @export
reduceDim <- function(PACds, nfeature=2000, dims=1:10, dimLabel='umap', norm=FALSE) {

  seuratObj<-SeuratObject::CreateSeuratObject(PACds@counts, assay = "PA")

  PACds=suppPACds(PACds, refresh = TRUE)

  # only count data can be normalized
  if (norm & PACds@supp$dataType=='count') {
    cat('Normalize data by LogNormalize...\n')
    seuratObj=Seurat::NormalizeData(seuratObj, normalization.method = "LogNormalize", verbose = FALSE)
  }

  # find HVG features
  cat('Find variable features...\n')
  seuratObj<-Seurat::FindVariableFeatures(seuratObj, selection.method = "vst", nfeatures=nfeature, verbose = FALSE)

  # scale data
  cat('Scale data...\n')
  features <- rownames(seuratObj)
  umap<- Seurat::ScaleData(seuratObj, features = features, verbose = FALSE)

  # PCA
  cat('Run PCA...\n')
  umap <- Seurat::RunPCA(umap, features = features, verbose=FALSE)

  # umap
  cat('Run UMAP...\n')
  umap<-Seurat::RunUMAP(object = umap, dims = dims, verbose=FALSE)
  umap = umap@reductions$umap@cell.embeddings %>% .asDf()
  colnames(umap)=paste0(dimLabel, 1:2)

  umap=umap[rownames(PACds@colData), ]

  if (AinB(colnames(umap), colnames(PACds@colData))) {
    PACds@colData[, colnames(umap)]=umap
  } else {
    PACds@colData=cbind(PACds@colData, umap)
  }
  return(PACds)
}


## given umap df, xcol, ycol and group labels or overlay value to plot UMAP
## the element text of the fig is all 10, and the name of overlay and annotation are shown as title (not legend)
getUMAPplot<-function(umap, xcol, ycol, group=NULL, overlay=NULL, statTheme=NULL) {
  ST=setStatTheme(statTheme)

  if (!is.numeric(umap[, xcol])) umap[, xcol]=as.numeric(as.character(umap[, xcol]))
  if (!is.numeric(umap[, ycol])) umap[, ycol]=as.numeric(as.character(umap[, ycol]))

  if (!is.null(group)) {
    p1 <- ggplot(umap, aes(x= .data[[xcol]] , y =  .data[[ycol]], color = .data[[group]])) +
      geom_point(size = ST$umap.point.size , alpha =ST$alpha)  +  scale_colour_manual(values = ST$group.cols)
    p1 = p1  + theme_classic() + ggtitle("Annotation") +
      theme(
        plot.title = element_text(hjust = 0.5), #, size=10
        text = element_text(size = 10),
        legend.title = element_blank(), # remove legend.title
        legend.key=element_rect(fill='white'), #
        legend.text = element_text(size=ST$umap.legend.size), # set legend size
        legend.key.size=ggplot2::unit(ST$umap.legend.key.size,'cm') ) +  # set size between legends
      guides(color = guide_legend(override.aes = list(size=ST$umap.legend.point.size))) # set point size in the legend
    return(p1)
  }

  if (!is.null(overlay)) {
    if (!is.numeric(umap[, overlay])) umap[, overlay]=as.numeric(as.character(umap[, overlay]))
    p2 <- ggplot(umap, aes(x= .data[[xcol]] , y =  .data[[ycol]], color = .data[[overlay]])) +
      geom_point(size = ST$umap.point.size , alpha =ST$alpha)  +  scale_color_gradient(low=ST$scale.low.col, high=ST$scale.high.col)
    p2 = p2  + theme_classic() + ggtitle(overlay) +
      theme(legend.title = element_blank(),
            plot.title = element_text(hjust = 0.5), # , size=10
            text = element_text(size = 10))
    return(p2)
  }
}


#' Plot a UMAP figure
#'
#' vizUMAP plots a UMAP plot where each point is a cell which is positioned based on the cell embeddings determined by the reduction technique.
#'
#' @param PACds A dataset of the PACdataset class.
#' @param group The column name recording cell categories in PACds@colData.
#' @param xcol the column name in PACds@colData denoting the X-axis coordinates of the 2D embedding.
#' @param ycol Same as xcol but for the Y-axis.  Both xcol and ycol are required to be in colData. See reduceDim() for getting 2D embeddings.
#' @param annoUMAP Whether to plot the UMAP only with cell annotation but no expression overlay.
#' @param selGroups A vector to specify the order and categories to plot, otherwise plot all or the first 10 (if N>10) categories.
#' @param genes A vector of gene names present in PACds@anno for filtering PACds.
#' @param PAs A vector of pA ids present in rownames of PACds@counts.
#'            If multiple genes or PAs are given, the average is calculated before drawing.
#'            If both gene and PAs are not provided, the average of all counts is obtained.
#' @param log TRUE to do log2 scale for the data, which is only applicable when PACds is count type.
#' @param statTheme A statTHEME-like list to specify the theme of the plot.
#' @return One (annoUMAP=FALSE) or two (annoUMAP=TRUE) UMAP plots.
#' @examples
#' \dontrun{
#' # First, we check the coordinate labels of the 2D-embedding.
#' # For this data, the labels are UMAP_1 and UMAP_2.
#' colnames(PACds@colData)
#' # Plot the UMAP plot showing cell clusters and another UMAP plot
#' # overlaying with the mean expression value of PAs in each cell.
#' vizUMAP(PACds, group='celltype', xcol='UMAP_1', ycol='UMAP_2')
#' # Plot only the overlaying UMAP
#' vizUMAP(PACds, group='celltype', annoUMAP=FALSE,
#'        xcol='UMAP_1', ycol='UMAP_2')
#' # Providing a gene id or a list of genes in the gene column of the PACds,
#' # we can plot a UMAP overlaying with the mean expression value of the gene(s).
#' vizUMAP(PACds, group='celltype', xcol='UMAP_1', ycol='UMAP_2', genes=gene)
#' vizUMAP(PACds, group='celltype', xcol='UMAP_1', ycol='UMAP_2',
#'        selGroups=c('SC','RS'), PAs=PAids)

#' ## get embeddings using the pA count matrix with normalization
#' PACds=reduceDim(PACds, nfeature=2000, dims=1:10,
#'                dimLabel='umap_norm', norm=TRUE)
#' ## without normalization
#' PACds=reduceDim(PACds, nfeature=2000, dims=1:10,
#'                dimLabel='umap_raw', norm=FALSE)
#' ## There are new columns adding to the colData slot.
#' head(PACds@colData)
#' vizUMAP(PACds, group='celltype', xcol='umap_raw1', ycol='umap_raw2')
#' vizUMAP(PACds, group='celltype',
#'        xcol='umap_norm1', ycol='umap_norm2')
#' vizUMAP(PACds, group='celltype', xcol='UMAP_1', ycol='UMAP_2')
#' }
#' @name vizUMAP
#' @family vizUMAP functions
#' @export
vizUMAP<-function(PACds, group, xcol, ycol, annoUMAP=TRUE,
                  selGroups=NULL, genes=NULL, PAs=NULL, log=FALSE, statTheme=NULL) {
  ST=setStatTheme(statTheme)
  cols=selGroups

  if (!AinB(c(group, xcol, ycol), colnames(PACds@colData), TRUE)) stop("group, xcol, ycol not all in @colData!")

  if (!is.null(genes) & !is.null(PAs)) stop("Can only specify genes or PAs!")

  PACds=suppPACds(PACds, refresh = TRUE)

  if (log & PACds@supp$dataType!='count') stop("@counts is not count but ratio data (<1), cannot apply log=TRUE!")

  if (is.null(cols)) {
    cols=unique(PACds@colData[, group])
  }

  if(length(cols)>10){
    message("Warning: too many groups (>10) to plot, only show the first 10, please use subsetPACds() to filter less groups")
    cols=cols[1:10]
  }

  PACds1=PACds
  if (!is.null(genes)) {
    PACds1=movAPA::subsetPACds(PACds, group=group, conds=cols, genes=genes)
  } else if (!is.null(PAs)) {
    if (PACds@supp$row!='PA') stop(" is not a PA list, cannot specify PAs!")
    PACds1=movAPA::subsetPACds(PACds, group=group, conds=cols, PAs=PAs)
  }

  if (length(PACds1)==0) {
    if (!annoUMAP) {
      cat("Not any data from and annoUMAP=FALSE, will not plot anything, return!\n")
      return(invisible(NULL))
    }
  } else {
    if (log) PACds1=logPACds(PACds1)
    d=data.frame(rowid=colnames(PACds1@counts), MEAN=colMeans(PACds1@counts, na.rm = TRUE))
  }

  ## anno UMAP
  cat( sprintf('vizUMAP: group=%s, x=%s, y=%s\n', group, xcol, ycol) )
  umap=data.frame(rowid=rownames(PACds1@colData), PACds1@colData[, c(group, xcol, ycol)])
  umap[, xcol]=as.numeric(as.character(umap[, xcol]))
  umap[, ycol]=as.numeric(as.character(umap[, ycol]))

  p=list()
  if (annoUMAP) {
    p[['annoUMAP']]=getUMAPplot(umap, xcol, ycol, group=group, overlay=NULL, statTheme=ST)
  }

  if (length(PACds1)>0) {
    ## overlayed UMAP
    umap=merge(umap, d, by.x='rowid', by.y='rowid') # group, tsne1, tsn2, MEAN
    p[['MEAN']]=getUMAPplot(umap, xcol, ycol, group=NULL, overlay='MEAN', statTheme=ST)
  }

  if (length(p)==2) {
    #labels=c('Annotation','Mean')
    plpages <- ggpubr::ggarrange(plotlist=p, nrow = 1, ncol = 2)
    #ggexport(plpages, filename = 'test.pdf')
    return(plpages)
  } else {
    return(p)
  }

}

# -------------- *** vizMarkers **** ---------------

#' Calculate the RUD index for each APA gene in a PACdataset
#'
#' getAPAindexPACds utilizes movAPA's movAPAindex to calculate the RUD index for each 3'UTR-APA gene in a PACdataset and returns a PACdataset.
#' This function only implements the RUD index in movAPA, users can use movAPA::movAPAindex for more types of APA index.
#'
#' @param PACds A dataset of the PACdataset class, which should be annotated with genomic regions, e.g., 3UTR.
#' @param choose2PA Specify whether and how to choose two PACs. The value can be NULL, PD (choose only proximal and distal sites), farest (choose two PACs that are with the longest distance), most (choose two PACs with the most abundance).
#' @return A new PACdataset with a RUD data frame with rownames denoting genes. Columns are samples, and values are the APA index values.
#' @examples
#' # Calculate the RUD index for each gene.
#' # Only genes with 3'UTR APA can be used for RUD calculation.
#' data(scPACds)
#' iPACds=getAPAindexPACds(scPACds, choose2PA='PD')
#' movAPA::summary(iPACds)
#' @name getAPAindexPACds
#' @family vizMarkers functions
#' @export
getAPAindexPACds <- function(PACds, choose2PA='PD') {
  APAindex <-
    movAPA::movAPAindex(
      PACds,
      method = "RUD",
      choose2PA = choose2PA,
      RUD.includeNon3UTR = FALSE
    )

  APAindex[is.na(APAindex)]<-0

  APAindex=APAindex2PACds(APAindex, colData = PACds@colData)
  return(APAindex)
}


#' Convert an APA index table to a PACdataset
#'
#' APAindex2PACds converts an APA index table to a PACdataset.
#' The APA index can be obtained by movAPA::movAPAindex, which is a table with each row denoting a gene and each column a sample (e.g., cell).
#' The element in the APA index table is the APA index for each APA gene, e.g., RUD, denoting the relative usage of distal pAs.
#'
#' @param APAindex A table with rownames denoting genes. Columns are samples, and values are the APA index values. If row names is NULL, then will be set as G1..Gn.
#' @param colData The sample information for the APAindex's columns. If is NULL, then will be automatically set as group1 for all samples.
#' @return A PACdataset with counts slot the APAindex table. However, this PACdataset is not the real PACdataset, which does not have chr/strand/coord columns.
#' It is just used in vizAPA for vizAPAmarkers.
#' @examples
#' #Calculate the smartRUD index for each gene.
#' #Only genes with 3'UTR APA can be used for RUD calculation.
#' data(scPACds)
#' pd=movAPA::get3UTRAPApd(pacds=scPACds, minDist=50, maxDist=5000,
#'                         minRatio=0.05, fixDistal=FALSE, addCols='pd')
#' srud=movAPA::movAPAindex(pd, method="smartRUD", sRUD.oweight=FALSE)
#' PACds=APAindex2PACds(srud, colData=pd@colData)
#' movAPA::summary(PACds)
#' @name APAindex2PACds
#' @family vizMarkers functions
#' @export
APAindex2PACds <- function(APAindex, colData=NULL) {

  APAindex[is.na(APAindex)]<-0

  if (is.null(rownames(APAindex))) {
    rownames(APAindex)=paste0('G', 1:nrow(APAindex))
    cat("APAindex2PACds: row names of APAindex is NULL, add like G1..Gn as row names!\n")
  }

  anno = data.frame(gene = rownames(APAindex))
  rownames(anno) = anno$gene

  if (!is.null(colData)) {
    ic=intersect(rownames(colData), colnames(APAindex))
    if (length(ic)!=ncol(APAindex)) {
      stop("APAindex2PACds: row names of colData should contain all column names of APAindex, each row/column is one sample!")
    }
  } else {
    colData=.asDf(matrix( rep('group1', ncol(APAindex)), ncol=1, dimnames =list(colnames(APAindex), 'group')) )
  }

  # make a fack PACds
  PACds = new(
    'PACdataset',
    counts = movAPA::asAnyMatrix(APAindex),
    colData = colData,
    anno = anno,
    supp = list(dataType = 'ratio', row = 'gene')
  )
  return(PACds)
}


# Convert PACds to Seurat obj
# NA.set: set NA in counts to NA.set; if NA.set=NULL, retain NA.
PACds2SeuratObject <- function(PACds, NA.set=0) {
  if (!is.null(NA.set)) PACds@counts[is.na(PACds@counts)]=NA.set
  obj <-Seurat::CreateSeuratObject(PACds@counts, meta.data =PACds@colData, assay = "PACds")
  return(obj)
}


#' Get APA markers among cell types
#'
#' getAPAmarkers finds APA markers among different cell types, leveraging Seurat's FindMarkers and FindAllMarkers functions on a PACdataset.
#'
#' @param PACds A dataset of the PACdataset class
#' @param group The column recording cell categories in PACds@colData.
#' @param cluster1 A category in the group.
#' @param cluster2 Another category in the group. If both cluster1/2 are provided, will compare the two clusters.
#'                 If only cluster1 or cluster2 is provided, then will compare the given cluster with another group containing all other cells.
#' @param everyPair if TRUE and both cluster1/2 are NULL, then will find markers for every pair of clusters in the group.
#'                  If cluster1 or cluster2 is provided, then everyPair is automatically set as FALSE.
#' @param method Denotes which test to use. See Seurat::FindMarkers(). Available options are:
#' "wilcox" : Identifies differentially expressed APA genes between two groups of cells using a Wilcoxon Rank Sum test (default)
#' "t" : Identify differentially expressed APA genes between two groups of cells using the Student's t-test.
#' "LR" : Uses a logistic regression framework to determine differentially expressed APA genes.
#'  Constructs a logistic regression model predicting group membership based on each feature individually and compares this to a null model with a likelihood ratio test.
#'  All the three methods are applicable to the count-type PACdataset, while only wilcox and t are applicable to the ratio-type PACdataset
#' @param only.pos Only return positive markers (FALSE by default). See Seurat::FindMarkers().
#' @param logFC log2FC threshold to filter significant markers.
#' @param min.pct Only test genes that are detected in a minimum fraction of min.pct cells in either of the two populations.
#'                Meant to speed up the function by not testing genes that are very infrequently expressed. Default is 0.1. See Seurat::FindMarkers().
#' @return A data frame of APA marker list with columns: p_val,avg_log2FC,pct.1,pct.2,p_val_adj,cluster1,cluster2.
#' @examples
#' data(scPACds)
#' getAPAmarkers(scPACds, group='celltype')
#' getAPAmarkers(scPACds, group='celltype', cluster1='ES')
#' getAPAmarkers(scPACds, group='celltype', cluster1='ES', cluster2='RS')
#' getAPAmarkers(scPACds,  group='celltype', cluster1='ES', cluster2='RS', method='t')
#' getAPAmarkers(scPACds,  group='celltype', cluster1='ES', cluster2='RS', method='LR')
#' @name getAPAmarkers
#' @family vizMarkers functions
#' @export
getAPAmarkers<-function(PACds, group, cluster1=NULL, cluster2=NULL, everyPair=TRUE,
                        method = c('wilcox'), only.pos=TRUE, logFC=0.25, min.pct=0.1) {

  PACds=suppPACds(PACds, refresh = TRUE)

  method=validate.arg(method, c('wilcox','t',' LR'))

  cat( sprintf('PACds row = %s, PACds dataType = %s\n', PACds@supp$row, PACds@supp$dataType) )

  if (PACds@supp$dataType == 'ratio' & method %in% c('LR')) stop("dataType of PACds is ratio, method should be wilcox or t!")

  # given count, no matter wehther it is index-type
  if (PACds@supp$row == 'gene' & PACds@supp$dataType == 'ratio') {
    cat('It seems that PACds is APA ratio, will apply wilcox-test on the APA index to get DE APA events (each row is an APA gene).\n')
  } else if (PACds@supp$row == 'PA' &
             PACds@supp$dataType == 'count') {
    cat('Warning: it seems that PACds is pA count, will get DE pAs (each row is a pA).\nIf you want APA markers, please use getAPAindexPACds() to transform your PACds to APA ratio.\n')
    #PACds=APAindexPACds(PACds, choose2PA = choose2PA)
  } else if (PACds@supp$row == 'gene' &
             PACds@supp$dataType == 'count') {
    cat('Warning: it seems that PACds is gene count, will get DE genes (each row is a gene).\nIf you want APA markers, please provide a PACds with APA ratios, see ?getAPAindexPACds.\n')
    #return(c())
  } else {
    cat('PACds@supp$row=',PACds@supp$row, ' PACds@supp$dataType=',PACds@supp$dataType,'\n')
    cat('Warning: do not know the type of the PACds, but still apply statistic test on the PACds.\nIf you want APA markers, please provide a PACds with APA ratios, see ?getAPAindexPACds\n')
  }

  stObj<- PACds2SeuratObject(PACds)
  Idents(stObj)=group

  # return cluster1 and cluster2, and rowid (the origninal row id for PA or gene)
  if (is.null(cluster1) & is.null(cluster2)) {
    if (everyPair) {  # Pairwise comparison of each pair of celltypes, return an additional cluster2 column in the list
      clusters=unique(PACds@colData[, group])
      mAll=c()
      for (i in 1:(length(clusters)-1)) {
        for (j in (i+1):length(clusters)) {
          cluster1=clusters[i]; cluster2=clusters[j]
          APAmarkers <- Seurat::FindMarkers(stObj, group.by=group, ident.1 = cluster1, ident.2=cluster2,
                                    only.pos = only.pos, min.pct = min.pct,
                                    logfc.threshold = logFC,
                                    test.use =method)
          APAmarkers$cluster1=cluster1
          APAmarkers$cluster2=cluster2
          APAmarkers$rowid=rownames(APAmarkers)
          if (i==1 & j==2) {
            mAll=APAmarkers
          } else {
            mAll=rbind(mAll, APAmarkers)
          }
        }
      }
      mAll<- mAll[order(mAll$cluster1, mAll$cluster2, mAll$p_val_adj, decreasing = F), ]
      return(mAll)

    } else { # each cell type and other all cells
      APAmarkers=Seurat::FindAllMarkers(stObj, group.by=group,
                                only.pos = only.pos,
                                min.pct = min.pct,
                                logfc.threshold = logFC,
                                test.use = method)
      colnames(APAmarkers)[colnames(APAmarkers)=='cluster']='cluster1'
      APAmarkers$cluster2=paste0('non-',APAmarkers$cluster1)
      APAmarkers$rowid=rownames(APAmarkers)
      APAmarkers<- APAmarkers[order(APAmarkers$cluster1, APAmarkers$p_val_adj, decreasing = F),]
      return(APAmarkers)
      #p_val avg_log2FC pct.1 pct.2     p_val_adj cluster    gene
      #PA19143 7.565134e-175   2.362515 0.833 0.105 5.832718e-172      ES PA19143
    }
  } else { # for a given ct1 and ct2
    if (is.null(cluster1)) {
      cluster1=cluster2
      cluster2=NULL
    }
    #p_val avg_log2FC pct.1 pct.2     p_val_adj
    #PA20634 7.532157e-231   1.797992 0.997 0.822 5.807293e-228
    APAmarkers <- Seurat::FindMarkers(stObj, group.by=group, ident.1 = cluster1, ident.2=cluster2,
                              only.pos = only.pos, min.pct = min.pct,
                              logfc.threshold = logFC,
                              test.use =method)
    APAmarkers$cluster1=cluster1
    APAmarkers$cluster2=ifelse(is.null(cluster2), paste0('non-',APAmarkers$cluster1), cluster2)
    APAmarkers$rowid=rownames(APAmarkers)
    APAmarkers<- APAmarkers[order(APAmarkers$p_val_adj, decreasing = F),]
    return(APAmarkers)
  }

}

#' Visualize APA markers
#'
#' vizAPAMarkers plots a violin plot, heatmap, bubble plot, or UMAP plot to show APA markers
#'
#' @param PACds A dataset of the PACdataset class, with each row is gene or pA.
#' @param group The column recording cell categories in PACds@colData.
#' @param selGroups A vector to specify the order and categories to plot, otherwise plot all or the first 10 (if N>10) categories.
#' @param markers A vector of gene names or PA ids considered as markers that should be all present in PACds@anno.
#' @param figType violin/heatmap/bubble/UMAP
#' @param umap.x The column name in PACds@colData denoting the X-axis coordinates for UMAP plot.
#' @param umap.y Same as umap.y but for the Y-axis.  Both umap.x and umap.y are required to be in colData. See reduceDim() for getting 2D embeddings.
#' @param annoUMAP Applicable when figType=umap, specify whether to plot the UMAP only with cell annotation but no expression overlay.
#' @param statTheme A statTHEME-like list to specify the theme of the plot.
#' @return A plot.
#' @examples
#' \dontrun{
#' data(scPACds); PACds=scPACds
#' m=getAPAmarkers(scPACds,  group='celltype', everyPair = TRUE)
#' vizAPAMarkers(PACds, group='celltype', markers=m$rowid[1:10],
#'              figType="violin")
#' vizAPAMarkers(PACds, group='celltype', markers=m$rowid[1:10],
#'              figType="violin", statTheme=list(xgroup=FALSE))
#' vizAPAMarkers(PACds, group='celltype', markers=m$rowid[1],
#'              figType="heatmap")
#' vizAPAMarkers(PACds, group='celltype', markers=m$rowid[1:10],
#'              figType="bubble")
#' vizAPAMarkers(PACds, group='celltype', selGroups=c('ES','SC'),
#'              markers=m$rowid[1:10], figType="bubble")

#' vizAPAMarkers(PACds, group='celltype', markers=m$rowid[1:10],
#'              figType="umap", umap.x='tsn1', umap.y='tsn2')
#' vizAPAMarkers(PACds, group='celltype', markers=m$rowid[1:10],
#'              figType="umap", umap.x='tsn1', umap.y='tsn2', annoUMAP=F)

#' iPACds=getAPAindexPACds(scPACds, choose2PA='PD')
#' m=getAPAmarkers(iPACds,  group='celltype', everyPair = TRUE, choose2PA='PD')
#' vizAPAMarkers(iPACds, group='celltype',
#'              markers=m$rowid[1:10], figType = 'violin')
#' vizAPAMarkers(iPACds, group='celltype', markers=m$rowid[1:10],
#'              figType = 'violin', statTheme=list(xgroup=FALSE))
#' vizAPAMarkers(iPACds, group='celltype', markers=m$rowid[1:10],
#'              figType = 'heatmap')
#' vizAPAMarkers(iPACds, group='celltype', markers=m$rowid[1:10],
#'              figType = 'bubble')
#' vizAPAMarkers(iPACds, group='celltype', markers=m$rowid[1:10],
#'              figType = 'bubble', statTheme=list(xgroup=FALSE))
#' }
#' @name vizAPAMarkers
#' @family vizMarkers functions
#' @export
vizAPAMarkers<-function(PACds, group, selGroups=NULL, markers,
                        figType=c('violin', 'heatmap', 'bubble', 'umap'),
                        umap.x=NULL, umap.y=NULL, annoUMAP=TRUE,
                        statTheme=NULL){

  cols=selGroups

  figType=validate.arg(figType, c('violin', 'heatmap', 'bubble', 'umap'))

  if (figType=='umap') {
    if (is.null(umap.x) | is.null(umap.y)) stop("figType=UMAP, should provide umap.x and umap.y!")
  }

  ST=setStatTheme(statTheme)

  PACds=suppPACds(PACds, refresh = TRUE)
  if (PACds@supp$dataType=='ratio') {
    ST$hm.disp.min=0; ST$hm.disp.max=1
  }

  PACds=movAPA::subsetPACds(PACds, group=group, conds=cols)

  if (!AinB(markers, rownames(PACds@counts))) stop("markers not all in rownames of PACds!")

  if (figType %in% c('violin', 'heatmap', 'bubble'))  stObj<-PACds2SeuratObject(PACds)

  if(figType=="violin"){
    fill.by=ifelse(ST$xgroup, 'ident','feature')
    p<- Seurat::VlnPlot(stObj, features=markers, pt.size=0, stack=TRUE, group.by=group, fill.by = fill.by,
                same.y.lims=TRUE, flip=ST$xgroup, cols=ST$group.cols) +
      theme(axis.title.x=element_blank(),
            axis.title.y=element_blank(),
            legend.position = "none" )
    return(p)
  }

  if(figType=="heatmap"){
    p<-Seurat::DoHeatmap(stObj, features=markers, slot = "data", assay='PACds', group.by=group,
                 disp.min=ST$hm.disp.min, disp.max=ST$hm.disp.max, group.colors=ST$group.cols,
                 label = ST$hm.label,
                 size = ST$hm.size,
                 hjust = ST$hm.hjust,
                 angle = ST$hm.angle,
                 raster = ST$hm.raster,
                 draw.lines = ST$hm.draw.lines,
                 lines.width = ST$hm.lines.width,
                 group.bar.height = ST$hm.group.bar.height)
    return(p)
  }

  if(figType=="bubble"){
    p<-Seurat::DotPlot(stObj, features = markers, group.by=group, col.min=ST$hm.disp.min, col.max=ST$hm.disp.max,
               cols=c(ST$scale.low.col, ST$scale.high.col), scale=ST$dot.scale) +
      theme(panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.border = element_blank(),
            axis.title = element_blank(),
            panel.background = element_rect(fill = 'white'),
            plot.background=element_rect(fill="white"),
            axis.text.x  = element_text(angle=90, vjust=0.5))
    if (ST$xgroup) p=p + coord_flip()
    return(p)
  }

  if (figType=='umap') {
    p=list()
    figlabs=c()
    if (annoUMAP) {
      p1=getUMAPplot(PACds@colData, xcol=umap.x, ycol=umap.y, group=group, overlay=NULL)
      p[['annoUMAP']]=p1
      figlabs='Annotation'
    }
    m1=cbind(rowid=rownames(PACds@colData), PACds@colData[, c(umap.x, umap.y)])
    for (m in markers) {
      m2=cbind(rowid=colnames(PACds@counts), .asDf(t(as.matrix(PACds@counts[m, , drop=F]))))
      colnames(m2)[2]=m
      umap=merge(m1, m2, by.x='rowid', by.y='rowid')
      p2=getUMAPplot(umap, xcol=umap.x, ycol=umap.y, group=NULL, overlay=m)
      p[[m]]=p2
      figlabs=c(figlabs, m)
    }
    nrow=floor(length(p)/ST$umaps.ncol)+(length(p)%%ST$umaps.ncol>0)
    plpages <- ggpubr::ggarrange(plotlist=p, nrow=nrow, ncol = ST$umaps.ncol) #, labels = figlabs
    return(plpages)
  }
}

